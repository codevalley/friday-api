This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-14T16:53:49.279Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
__tests__/
  repositories/
    test_AuthorRepository.py
    test_BookRepository.py
  services/
    test_AuthorService.py
    test_BookService.py
  unit/
    models/
      test_activity_model.py
      test_moment_model.py
  conftest.py
  test_user_auth.py
.github/
  FUNDING.yml
configs/
  Database.py
  Environment.py
  GraphQL.py
  OpenAPI.py
metadata/
  Tags.py
models/
  ActivityModel.py
  BaseModel.py
  MomentModel.py
  UserModel.py
repositories/
  ActivityRepository.py
  BaseRepository.py
  MomentRepository.py
  RepositoryMeta.py
  UserRepository.py
routers/
  v1/
    ActivityRouter.py
    AuthRouter.py
    MomentRouter.py
schemas/
  base/
    activity_schema.py
    moment_schema.py
    user_schema.py
  graphql/
    mutations/
      ActivityMutation.py
      MomentMutation.py
      UserMutation.py
    types/
      Activity.py
      Moment.py
      User.py
    Mutation.py
    Query.py
  pydantic/
    ActivitySchema.py
    MomentSchema.py
    PaginationSchema.py
    UserSchema.py
services/
  ActivityService.py
  MomentService.py
  UserService.py
utils/
  json_utils.py
  security.py
.env.test
.gitignore
.pre-commit-config.yaml
.python-version
.windsurfrules
dependencies.py
LICENSE
main.py
mypy.ini
Pipfile
pyproject.toml
README.md

================================================================
Repository Files
================================================================

================
File: __tests__/repositories/test_AuthorRepository.py
================
from sqlalchemy.orm import Session
from unittest import TestCase
from unittest.mock import create_autospec, patch

from repositories.AuthorRepository import AuthorRepository


class TestAuthorRepository(TestCase):
    session: Session
    authorRepository: AuthorRepository

    def setUp(self):
        super().setUp()
        self.session = create_autospec(Session)
        self.authorRepository = AuthorRepository(
            self.session
        )

    @patch("models.AuthorModel.Author", autospec=True)
    def test_create(self, Author):
        author = Author(name="JK Rowling")
        self.authorRepository.create(author)

        # Should call add method on Session
        self.session.add.assert_called_once_with(author)

    @patch("models.AuthorModel.Author", autospec=True)
    def test_delete(self, Author):
        author = Author(id=1)
        self.authorRepository.delete(author)

        # Should call delete method on Session
        self.session.delete.assert_called_once_with(author)

    @patch("models.AuthorModel.Author", autospec=True)
    def test_get(self, Author):
        author = Author(id=1)
        self.authorRepository.get(author)

        # Should call get method on Session
        self.session.get.assert_called_once()

    @patch("models.AuthorModel.Author", autospec=True)
    def test_list(self, Author):
        self.authorRepository.list(None, 100, 0)

        # Should call query method on Session
        self.session.query.assert_called_once()

        self.authorRepository.list("Stephen Knight", 100, 0)

        # Should call filter_by method on QueryResponse
        self.session.query(
            Author
        ).filter_by.assert_called_once_with(
            name="Stephen Knight"
        )

    @patch("models.AuthorModel.Author", autospec=True)
    def test_update(self, Author):
        author = Author(name="Ray Dalio")
        self.authorRepository.update(id=1, author=author)

        # Should call merge method on Session
        self.session.merge.assert_called_once_with(author)

================
File: __tests__/repositories/test_BookRepository.py
================
from sqlalchemy.orm import Session
from unittest import TestCase
from unittest.mock import create_autospec, patch

from repositories.BookRepository import BookRepository


class TestBookRepository(TestCase):
    session: Session
    bookRepository: BookRepository

    def setUp(self):
        super().setUp()
        self.session = create_autospec(Session)
        self.bookRepository = BookRepository(self.session)

    @patch("models.BookModel.Book", autospec=True)
    def test_create(self, Book):
        book = Book(
            name="Harry Potter and The Order of Phoenix"
        )
        self.bookRepository.create(book)

        # Should call add method on Session
        self.session.add.assert_called_once_with(book)

    @patch("models.BookModel.Book", autospec=True)
    def test_delete(self, Book):
        book = Book(id=1)
        self.bookRepository.delete(book)

        # Should call delete method on Session
        self.session.delete.assert_called_once_with(book)

    @patch("models.BookModel.Book", autospec=True)
    def test_get(self, Book):
        book = Book(id=1)
        self.bookRepository.get(book)

        # Should call get method on Session
        self.session.get.assert_called_once()

    @patch("models.BookModel.Book", autospec=True)
    def test_list(self, Book):
        self.bookRepository.list(None, 100, 0)

        # Should call query method on Session
        self.session.query.assert_called_once()

        self.bookRepository.list("Peaky Blinders", 100, 0)

        # Should call filter_by method on QueryResponse
        self.session.query(
            Book
        ).filter_by.assert_called_once_with(
            name="Peaky Blinders"
        )

    @patch("models.BookModel.Book", autospec=True)
    def test_update(self, Book):
        book = Book(name="The Wealth of Nations")
        self.bookRepository.update(id=1, book=book)

        # Should call merge method on Session
        self.session.merge.assert_called_once_with(book)

================
File: __tests__/services/test_AuthorService.py
================
from unittest import TestCase
from unittest.mock import create_autospec, patch

from repositories.AuthorRepository import AuthorRepository
from repositories.BookRepository import BookRepository
from services.AuthorService import AuthorService


class TestAuthorService(TestCase):
    authorRepository: AuthorRepository
    authorService: AuthorService

    def setUp(self):
        super().setUp()
        self.authorRepository = create_autospec(
            AuthorRepository
        )
        self.authorRepository = create_autospec(
            BookRepository
        )
        self.authorService = AuthorService(
            self.authorRepository
        )

    @patch(
        "schemas.pydantic.AuthorSchema.AuthorSchema",
        autospec=True,
    )
    def test_create(self, AuthorSchema):
        author = AuthorSchema()
        author.name = "JK Rowling"

        self.authorService.create(author)

        # Should call create method on Author Repository
        self.authorRepository.create.assert_called_once()

    def test_delete(self):
        self.authorService.delete(author_id=1)

        # Should call delete method on Author Repository
        self.authorRepository.delete.assert_called_once()

    def test_get(self):
        self.authorService.get(author_id=1)

        # Should call get method on Author Repository
        self.authorRepository.get.assert_called_once()

    def test_list(self):
        name = "Rowling"
        pageSize = 10
        startIndex = 2

        self.authorService.list(name, pageSize, startIndex)

        # Should call list method on Author Repository
        self.authorRepository.list.assert_called_once_with(
            name, pageSize, startIndex
        )

    @patch(
        "schemas.pydantic.AuthorSchema.AuthorSchema",
        autospec=True,
    )
    def test_update(self, AuthorSchema):
        author = AuthorSchema()
        author.name = "JRR Tokein"

        self.authorService.update(
            author_id=1, author_body=author
        )

        # Should call update method on Book Repository
        self.authorRepository.update.assert_called_once()

================
File: __tests__/services/test_BookService.py
================
from unittest import TestCase
from unittest.mock import create_autospec, patch

from repositories.AuthorRepository import AuthorRepository
from repositories.BookRepository import BookRepository
from services.BookService import BookService


class TestBookService(TestCase):
    authorRepository: AuthorRepository
    bookRepository: BookRepository
    bookService: BookService

    def setUp(self):
        super().setUp()
        self.authorRepository = create_autospec(
            AuthorRepository
        )
        self.bookRepository = create_autospec(
            BookRepository
        )
        self.bookService = BookService(
            self.authorRepository, self.bookRepository
        )

    @patch(
        "schemas.pydantic.BookSchema.BookSchema",
        autospec=True,
    )
    def test_create(self, BookSchema):
        book = BookSchema()
        book.name = "Harry Potter and The Order of Phoenix"

        self.bookService.create(book)

        # Should call create method on Book Repository
        self.bookRepository.create.assert_called_once()

    def test_delete(self):
        self.bookService.delete(book_id=1)

        # Should call delete method on Book Repository
        self.bookRepository.delete.assert_called_once()

    def test_get(self):
        self.bookService.get(book_id=1)

        # Should call get method on Book Repository
        self.bookRepository.get.assert_called_once()

    def test_list(self):
        name = "The Richest Man in Babylon"
        pageSize = 10
        startIndex = 2

        self.bookService.list(name, pageSize, startIndex)

        # Should call list method on Book Repository
        self.bookRepository.list.assert_called_once_with(
            name, pageSize, startIndex
        )

    @patch(
        "schemas.pydantic.BookSchema.BookSchema",
        autospec=True,
    )
    def test_update(self, BookSchema):
        book = BookSchema()
        book.name = "Harry Potter and The Order of Phoenix"

        self.bookService.update(book_id=1, book_body=book)

        # Should call update method on Book Repository
        self.bookRepository.update.assert_called_once()

    def test_get_authors(self):
        self.bookService.get_authors(book_id=1)

        # Should call get method on Book Repository
        self.bookRepository.get.assert_called_once()

    @patch(
        "schemas.pydantic.BookSchema.BookAuthorPostRequestSchema",
        autospec=True,
    )
    def test_add_author(self, BookAuthorPostRequestSchema):
        author = BookAuthorPostRequestSchema()
        author.author_id = 3

        self.bookService.add_author(
            book_id=1, author_body=author
        )

        # Should call get method on Author Repository
        self.authorRepository.get.assert_called_once()

        # Should call get method on Book Repository
        self.bookRepository.get.assert_called_once()

        # Should call update method on Book Repository
        self.bookRepository.update.assert_called_once()

    def test_remove_author(self):
        self.bookService.remove_author(
            book_id=1, author_id=2
        )

        # Should call get method on Book Repository
        self.bookRepository.get.assert_called_once()

        # Should call update method on Book Repository
        self.bookRepository.update.assert_called_once()

================
File: __tests__/unit/models/test_activity_model.py
================
import pytest
from sqlalchemy.exc import IntegrityError

from models.ActivityModel import Activity
from models.MomentModel import Moment


def test_activity_model_initialization(sample_activity):
    """Test that an activity can be created with valid data"""
    activity = Activity(**sample_activity)

    assert activity.name == sample_activity["name"]
    assert (
        activity.description
        == sample_activity["description"]
    )
    assert (
        activity.activity_schema
        == sample_activity["activity_schema"]
    )
    assert activity.icon == sample_activity["icon"]
    assert activity.color == sample_activity["color"]
    assert activity.moments == []


def test_activity_model_db_persistence(
    db_session, sample_activity
):
    """Test that an activity can be persisted to the database"""
    activity = Activity(**sample_activity)
    db_session.add(activity)
    db_session.commit()

    saved_activity = (
        db_session.query(Activity)
        .filter_by(name=sample_activity["name"])
        .first()
    )
    assert saved_activity is not None
    assert saved_activity.name == sample_activity["name"]


def test_activity_moment_relationship(
    db_session, sample_activity, sample_moment
):
    """Test the relationship between Activity and Moment models"""
    activity = Activity(**sample_activity)
    db_session.add(activity)
    db_session.flush()

    moment = Moment(
        activity_id=activity.id,
        timestamp=sample_moment["timestamp"],
        data=sample_moment["data"],
    )
    db_session.add(moment)
    db_session.commit()

    # Refresh activity to get updated relationships
    db_session.refresh(activity)
    assert len(activity.moments) == 1
    assert activity.moments[0].data == sample_moment["data"]


def test_activity_name_unique_constraint(
    db_session, sample_activity
):
    """Test that activity names must be unique"""
    activity1 = Activity(**sample_activity)
    db_session.add(activity1)
    db_session.commit()

    activity2 = Activity(**sample_activity)
    db_session.add(activity2)

    with pytest.raises(IntegrityError):
        db_session.commit()


def test_activity_required_fields(db_session):
    """Test that required fields raise appropriate errors when missing"""
    activity = Activity()  # Missing required fields
    db_session.add(activity)

    with pytest.raises(IntegrityError):
        db_session.commit()


def test_activity_schema_validation():
    """Test that activity_schema must be a valid JSON object"""
    invalid_schema_activity = Activity(
        name="test_activity",
        activity_schema="invalid_json",  # Should be a dict
        icon="ðŸ“",
        color="#000000",
    )

    with pytest.raises(ValueError):
        invalid_schema_activity.validate_schema()

================
File: __tests__/unit/models/test_moment_model.py
================
import pytest
from datetime import datetime, timezone
from sqlalchemy.exc import IntegrityError

from models.ActivityModel import Activity
from models.MomentModel import Moment


def test_moment_model_initialization(
    db_session, sample_activity, sample_moment
):
    """Test that a moment can be created with valid data"""
    activity = Activity(**sample_activity)
    db_session.add(activity)
    db_session.flush()

    moment = Moment(
        activity_id=activity.id,
        timestamp=sample_moment["timestamp"],
        data=sample_moment["data"],
    )

    assert moment.activity_id == activity.id
    assert moment.timestamp == sample_moment["timestamp"]
    assert moment.data == sample_moment["data"]


def test_moment_model_db_persistence(
    db_session, sample_activity, sample_moment
):
    """Test that a moment can be persisted to the database"""
    activity = Activity(**sample_activity)
    db_session.add(activity)
    db_session.flush()

    moment = Moment(
        activity_id=activity.id,
        timestamp=sample_moment["timestamp"],
        data=sample_moment["data"],
    )
    db_session.add(moment)
    db_session.commit()

    saved_moment = (
        db_session.query(Moment)
        .filter_by(activity_id=activity.id)
        .first()
    )
    assert saved_moment is not None
    assert saved_moment.data == sample_moment["data"]


def test_moment_activity_relationship(
    db_session, sample_activity, sample_moment
):
    """Test the relationship between Moment and Activity models"""
    activity = Activity(**sample_activity)
    db_session.add(activity)
    db_session.flush()

    moment = Moment(
        activity_id=activity.id,
        timestamp=sample_moment["timestamp"],
        data=sample_moment["data"],
    )
    db_session.add(moment)
    db_session.commit()

    assert moment.activity == activity
    assert moment.activity.name == sample_activity["name"]


def test_moment_cascade_delete(
    db_session, sample_activity, sample_moment
):
    """Test that moments are deleted when their activity is deleted"""
    activity = Activity(**sample_activity)
    db_session.add(activity)
    db_session.flush()

    moment = Moment(
        activity_id=activity.id,
        timestamp=sample_moment["timestamp"],
        data=sample_moment["data"],
    )
    db_session.add(moment)
    db_session.commit()

    # Delete the activity
    db_session.delete(activity)
    db_session.commit()

    # Check that the moment was also deleted
    assert (
        db_session.query(Moment)
        .filter_by(id=moment.id)
        .first()
        is None
    )


def test_moment_required_fields(db_session):
    """Test that required fields raise appropriate errors when missing"""
    moment = Moment()  # Missing required fields
    db_session.add(moment)

    with pytest.raises(IntegrityError):
        db_session.commit()


def test_moment_data_validation(
    db_session, sample_activity
):
    """Test that moment data must be a valid JSON object"""
    activity = Activity(**sample_activity)
    db_session.add(activity)
    db_session.flush()

    moment = Moment(
        activity_id=activity.id,
        timestamp=datetime.now(timezone.utc),
        data="invalid_json",  # Should be a dict
    )

    with pytest.raises(ValueError):
        moment.validate_data()

================
File: __tests__/conftest.py
================
import pytest
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from datetime import datetime, timezone

from models.BaseModel import EntityMeta

# Test database URL should be configured in .env.test
from configs.Environment import get_environment_variables


@pytest.fixture(scope="session")
def engine():
    """Create engine for test database"""
    env = get_environment_variables()
    db_url = (
        f"{env.DATABASE_DIALECT}://"
        f"{env.DATABASE_USERNAME}:{env.DATABASE_PASSWORD}"
        f"@{env.DATABASE_HOSTNAME}:{env.DATABASE_PORT}"
        f"/{env.DATABASE_NAME}"
    )
    test_engine = create_engine(db_url)

    # Create all tables
    EntityMeta.metadata.drop_all(
        bind=test_engine
    )  # Clean slate
    EntityMeta.metadata.create_all(bind=test_engine)

    return test_engine


@pytest.fixture(scope="function")
def db_session(engine):
    """Provide a clean database session for each test"""
    connection = engine.connect()
    transaction = connection.begin()
    Session = sessionmaker(bind=connection)
    session = Session()

    yield session

    session.close()
    transaction.rollback()
    connection.close()


@pytest.fixture
def sample_activity():
    """Create a sample activity for testing"""
    return {
        "name": "test_activity",
        "description": "Test activity description",
        "activity_schema": {
            "type": "object",
            "properties": {"notes": {"type": "string"}},
        },
        "icon": "ðŸ“",
        "color": "#000000",
    }


@pytest.fixture
def sample_moment(sample_activity):
    """Create a sample moment for testing"""
    return {
        "timestamp": datetime.now(timezone.utc),
        "data": {"notes": "Test moment"},
        "activity_data": sample_activity,
    }

================
File: __tests__/test_user_auth.py
================
import pytest
from fastapi.testclient import TestClient

from main import app
from models.UserModel import User
from configs.Database import (
    get_db_connection,
    SessionLocal,
    Engine,
)


# Create a test database session
def override_get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


# Override the database dependency
app.dependency_overrides[get_db_connection] = (
    override_get_db
)

client = TestClient(app)


@pytest.fixture(autouse=True)
def setup_database():
    # Set up - create tables
    User.__table__.create(bind=Engine, checkfirst=True)

    # Run the test
    yield

    # Tear down - drop tables
    User.__table__.drop(bind=Engine, checkfirst=True)


def test_register_user():
    response = client.post(
        "/v1/auth/register", json={"username": "testuser"}
    )
    assert response.status_code == 200
    data = response.json()
    assert "id" in data
    assert data["username"] == "testuser"
    assert "user_secret" in data


def test_register_duplicate_username():
    # First registration
    response1 = client.post(
        "/v1/auth/register",
        json={"username": "duplicate_user"},
    )
    assert response1.status_code == 200

    # Second registration with same username
    response2 = client.post(
        "/v1/auth/register",
        json={"username": "duplicate_user"},
    )
    assert response2.status_code == 400
    assert (
        "Username already registered"
        in response2.json()["detail"]
    )


def test_login_with_valid_secret():
    # First register a user
    register_response = client.post(
        "/v1/auth/register", json={"username": "loginuser"}
    )
    user_secret = register_response.json()["user_secret"]

    # Then try to login
    login_response = client.post(
        "/v1/auth/token", json={"user_secret": user_secret}
    )
    assert login_response.status_code == 200
    data = login_response.json()
    assert "access_token" in data
    assert data["token_type"] == "bearer"


def test_login_with_invalid_secret():
    login_response = client.post(
        "/v1/auth/token",
        json={"user_secret": "invalid_secret"},
    )
    assert login_response.status_code == 401
    assert (
        "Invalid credentials"
        in login_response.json()["detail"]
    )


def test_protected_endpoint_with_valid_token():
    # First register and get a token
    register_response = client.post(
        "/v1/auth/register",
        json={"username": "protecteduser"},
    )
    user_secret = register_response.json()["user_secret"]

    login_response = client.post(
        "/v1/auth/token", json={"user_secret": user_secret}
    )
    token = login_response.json()["access_token"]

    # Then try to access protected endpoint
    response = client.get(
        "/v1/activities",
        headers={"Authorization": f"Bearer {token}"},
    )
    assert response.status_code == 200


def test_protected_endpoint_without_token():
    response = client.get("/v1/activities")
    assert response.status_code == 401
    assert "Not authenticated" in response.json()["detail"]


def test_protected_endpoint_with_invalid_token():
    response = client.get(
        "/v1/activities",
        headers={"Authorization": "Bearer invalid_token"},
    )
    assert response.status_code == 401
    assert (
        "Could not validate credentials"
        in response.json()["detail"]
    )

================
File: .github/FUNDING.yml
================
# List of Supported Funding Platforms

github: 0xTheProDev

================
File: configs/Database.py
================
from sqlalchemy import create_engine
from sqlalchemy.orm import scoped_session, sessionmaker

from configs.Environment import get_environment_variables

# Runtime Environment Configuration
env = get_environment_variables()

# Generate Database URL
DATABASE_URL = (
    f"{env.DATABASE_DIALECT}://"
    f"{env.DATABASE_USERNAME}:{env.DATABASE_PASSWORD}"
    f"@{env.DATABASE_HOSTNAME}:{env.DATABASE_PORT}"
    f"/{env.DATABASE_NAME}"
)

# Create Database Engine
Engine = create_engine(
    DATABASE_URL, echo=env.DEBUG_MODE, future=True
)

SessionLocal = sessionmaker(
    autocommit=False, autoflush=False, bind=Engine
)


def get_db_connection():
    db = scoped_session(SessionLocal)
    try:
        yield db
    finally:
        db.close()

================
File: configs/Environment.py
================
from functools import lru_cache
import os

from pydantic_settings import BaseSettings


@lru_cache
def get_env_filename():
    runtime_env = os.getenv("ENV")
    return f".env.{runtime_env}" if runtime_env else ".env"


class EnvironmentSettings(BaseSettings):
    API_VERSION: str
    APP_NAME: str
    DATABASE_DIALECT: str
    DATABASE_HOSTNAME: str
    DATABASE_NAME: str
    DATABASE_PASSWORD: str
    DATABASE_PORT: int
    DATABASE_USERNAME: str
    DEBUG_MODE: bool

    class Config:
        env_file = get_env_filename()
        env_file_encoding = "utf-8"


@lru_cache
def get_environment_variables():
    return EnvironmentSettings()

================
File: configs/GraphQL.py
================
from fastapi import Depends, Request
from strawberry.types import Info
from sqlalchemy.orm import Session
from typing import Optional

from services.ActivityService import ActivityService
from services.MomentService import MomentService
from configs.Database import get_db_connection
from dependencies import get_optional_user
from models.UserModel import User


# GraphQL Dependency Context
async def get_graphql_context(
    request: Request,
    activity_service: ActivityService = Depends(),
    moment_service: MomentService = Depends(),
    db: Session = Depends(get_db_connection),
    current_user: Optional[User] = Depends(
        get_optional_user
    ),
):
    # Check if it's a GraphiQL request
    is_graphiql = (
        request.headers.get("accept", "").find("text/html")
        != -1
    )

    return {
        "activity_service": activity_service,
        "moment_service": moment_service,
        "db": db,
        "user": current_user,
        "is_graphiql": is_graphiql,
    }


# Extract ActivityService instance from GraphQL context
def get_ActivityService(info: Info) -> ActivityService:
    return info.context["activity_service"]


# Extract MomentService instance from GraphQL context
def get_MomentService(info: Info) -> MomentService:
    return info.context["moment_service"]


# Extract database session from GraphQL context
def get_db_from_context(info: Info) -> Session:
    return info.context["db"]


# Extract current user from GraphQL context
def get_user_from_context(info: Info) -> Optional[User]:
    return info.context.get("user")

================
File: configs/OpenAPI.py
================
from fastapi.security import HTTPBearer

# Bearer token security scheme
bearer_scheme = HTTPBearer(
    scheme_name="Bearer",
    description="JWT token obtained from /v1/auth/token using your API key",
    auto_error=False,  # Make authentication optional
)

# Instance to use in FastAPI dependencies
security = bearer_scheme

================
File: metadata/Tags.py
================
Tags = [
    {
        "name": "activities",
        "description": "Create, manage activity types with custom JSON schema",
    },
    {
        "name": "moments",
        "description": "Log and track moments with structured data",
    },
]

================
File: models/ActivityModel.py
================
from sqlalchemy import (
    Column,
    Integer,
    String,
    JSON,
    CheckConstraint,
    ForeignKey,
    select,
    func,
)
from sqlalchemy.orm import relationship, column_property
from jsonschema import validate as validate_json_schema
import json
from typing import Any, Dict, cast

from models.BaseModel import EntityMeta
from models.MomentModel import Moment


class Activity(EntityMeta):
    """
    Activity Model represents different types of activities
    that can be logged as moments.
    Each activity defines its own schema for validating moment data.
    """

    __tablename__ = "activities"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(
        String(36),
        ForeignKey("users.id", ondelete="CASCADE"),
        nullable=False,
    )
    name = Column(String(255), nullable=False)
    description = Column(String(1000))
    activity_schema = Column(
        JSON, nullable=False
    )  # JSON Schema for validating moment data
    icon = Column(String(255), nullable=False)
    color = Column(String(7), nullable=False)

    # Add moment_count as a column property
    moment_count = column_property(
        select(func.count(Moment.id))
        .where(Moment.activity_id == id)
        .scalar_subquery()
    )

    # Relationships
    user = relationship("User", back_populates="activities")
    moments = relationship(
        "Moment",
        back_populates="activity",
        cascade="all, delete-orphan",
    )

    # Constraints
    __table_args__ = (
        CheckConstraint(
            "name IS NOT NULL AND name != ''",
            name="check_name_not_empty",
        ),
        CheckConstraint(
            "activity_schema IS NOT NULL",
            name="check_schema_not_null",
        ),
        CheckConstraint(
            "icon IS NOT NULL AND icon != ''",
            name="check_icon_not_empty",
        ),
        CheckConstraint(
            "color IS NOT NULL AND color != ''",
            name="check_color_not_empty",
        ),
    )

    def __repr__(self):
        return (
            f"<Activity(id={self.id}, name='{self.name}')>"
        )

    @property
    def activity_schema_dict(self) -> Dict[str, Any]:
        """Return activity_schema as a dictionary"""
        schema = self.activity_schema
        if schema is None:
            return {}
        if isinstance(schema, str):
            return json.loads(schema)
        if isinstance(schema, dict):
            return schema
        return cast(Dict[str, Any], schema)

    def validate_schema(self):
        """Validate that the activity_schema is a valid JSON Schema"""
        schema_dict = self.activity_schema_dict
        if not isinstance(schema_dict, dict):
            raise ValueError(
                "activity_schema must be a valid JSON object"
            )

        # Basic schema validation - should be a valid JSON Schema
        meta_schema = {
            "type": "object",
            "properties": {
                "type": {"type": "string"},
                "properties": {"type": "object"},
            },
            "required": ["type"],
        }

        try:
            validate_json_schema(schema_dict, meta_schema)
        except Exception as e:
            raise ValueError(
                f"Invalid JSON Schema: {str(e)}"
            )

        return True

    def validate_moment_data(
        self, moment_data: Dict[str, Any]
    ) -> bool:
        """
        Validate moment data against the activity's schema
        Returns True if valid, raises ValidationError if invalid
        """
        try:
            schema = self.activity_schema_dict
            validate_json_schema(moment_data, schema)
            return True
        except Exception as e:
            raise ValueError(
                f"Invalid moment data: {str(e)}"
            )

================
File: models/BaseModel.py
================
from typing import Type
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import DeclarativeMeta

from configs.Database import Engine

# Create base with type information
Base = declarative_base()
EntityMeta: Type[DeclarativeMeta] = Base


def init():
    EntityMeta.metadata.create_all(bind=Engine)

================
File: models/MomentModel.py
================
from sqlalchemy import (
    Column,
    Integer,
    DateTime,
    JSON,
    ForeignKey,
    String,
    CheckConstraint,
)
from sqlalchemy.orm import relationship
from datetime import datetime, timezone
from jsonschema import validate as validate_json_schema
import json
from typing import Any, Dict, cast

from models.BaseModel import EntityMeta


class Moment(EntityMeta):
    """
    Moment Model represents a single moment or event in a person's life.
    Each moment is associated with an activity type and contains data
    specific to that activity.
    """

    __tablename__ = "moments"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(
        String(36),
        ForeignKey("users.id", ondelete="CASCADE"),
        nullable=False,
    )
    activity_id = Column(
        Integer,
        ForeignKey("activities.id", ondelete="CASCADE"),
        nullable=False,
    )
    data = Column(JSON, nullable=False)
    timestamp = Column(
        DateTime(timezone=True),
        index=True,
        nullable=False,
        default=lambda: datetime.now(timezone.utc),
    )

    # Relationships
    user = relationship("User", back_populates="moments")
    activity = relationship(
        "Activity", back_populates="moments"
    )

    # Constraints
    __table_args__ = (
        CheckConstraint(
            "timestamp IS NOT NULL",
            name="check_timestamp_not_null",
        ),
        CheckConstraint(
            "activity_id IS NOT NULL",
            name="check_activity_id_not_null",
        ),
        CheckConstraint(
            "data IS NOT NULL", name="check_data_not_null"
        ),
        CheckConstraint(
            "user_id IS NOT NULL",
            name="check_user_id_not_null",
        ),
    )

    def __repr__(self):
        return (
            f"<Moment(id={self.id}, activity_id={self.activity_id}, "
            f"timestamp='{self.timestamp}')>"
        )

    @property
    def data_dict(self) -> Dict[str, Any]:
        """Return data as a dictionary"""
        data = self.data
        if data is None:
            return {}
        if isinstance(data, str):
            return json.loads(data)
        if isinstance(data, dict):
            return data
        return cast(Dict[str, Any], data)

    def validate_data(self):
        """Validate that the moment data matches the activity's schema"""
        data = self.data_dict
        if not isinstance(data, dict):
            raise ValueError(
                "moment data must be a valid JSON object"
            )

        if (
            not self.activity
            or not self.activity.activity_schema
        ):
            raise ValueError(
                "moment must be linked to an activity with a valid schema"
            )

        try:
            schema = self.activity.activity_schema_dict
            validate_json_schema(data, schema)
        except Exception as e:
            raise ValueError(
                f"Invalid moment data: {str(e)}"
            )

        return True

================
File: models/UserModel.py
================
from sqlalchemy import Column, String, DateTime
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from uuid import uuid4

from models.BaseModel import EntityMeta


class User(EntityMeta):
    """User Model represents a registered user in the system"""

    __tablename__ = "users"

    id = Column(
        String(36),  # UUID length is 36 characters
        primary_key=True,
        default=lambda: str(uuid4()),
        index=True,
    )
    username = Column(
        String(50),  # Max length of 50 characters
        unique=True,
        index=True,
        nullable=False,
    )
    key_id = Column(
        String(36),  # UUID length is 36 characters
        unique=True,
        index=True,
        nullable=False,
    )
    user_secret = Column(
        String(64),  # Length for secure secret
        nullable=False,
    )

    # Timestamps
    created_at = Column(
        DateTime(timezone=True),
        server_default=func.now(),
        nullable=False,
    )
    updated_at = Column(
        DateTime(timezone=True),
        server_default=func.now(),
        onupdate=func.now(),
        nullable=False,
    )

    # Relationships
    activities = relationship(
        "Activity",
        back_populates="user",
        cascade="all, delete-orphan",
    )
    moments = relationship(
        "Moment",
        back_populates="user",
        cascade="all, delete-orphan",
    )

    def __repr__(self):
        return f"<User(id={self.id}, username={self.username})>"

================
File: repositories/ActivityRepository.py
================
from typing import List, Optional, Dict, Any, Union
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError
from fastapi import HTTPException, status

from models.ActivityModel import Activity
from .BaseRepository import BaseRepository


class ActivityRepository(BaseRepository[Activity, int]):
    """Repository for managing Activity entities"""

    def __init__(self, db: Session):
        """Initialize with database session

        Args:
            db: SQLAlchemy database session
        """
        super().__init__(db, Activity)

    def create(
        self,
        instance_or_name: Union[Activity, str],
        *,  # Force keyword arguments
        description: Optional[str] = None,
        activity_schema: Optional[dict] = None,
        icon: Optional[str] = None,
        color: Optional[str] = None,
        user_id: Optional[str] = None,
    ) -> Activity:
        """Create a new activity

        This method supports two ways of creating an activity:
        1. Passing an Activity instance directly
        2. Passing individual fields

        Args:
            instance_or_name: Either an Activity instance or the activity name
            description: Activity description (if creating by fields)
            activity_schema: Activity schema (if creating by fields)
            icon: Activity icon (if creating by fields)
            color: Activity color (if creating by fields)
            user_id: Owner's user ID (if creating by fields)

        Returns:
            Created Activity instance
        """
        if isinstance(instance_or_name, Activity):
            return super().create(instance_or_name)

        # Create new instance from fields
        activity = Activity(
            name=instance_or_name,
            description=description,
            activity_schema=activity_schema,
            icon=icon,
            color=color,
            user_id=user_id,
        )
        return super().create(activity)

    def get_by_user(
        self, activity_id: int, user_id: str
    ) -> Optional[Activity]:
        """Get an activity by ID and verify ownership

        Args:
            activity_id: Activity ID
            user_id: User ID to verify ownership

        Returns:
            Activity if found and owned by user, None otherwise
        """
        return (
            self.db.query(Activity)
            .filter(
                Activity.id == activity_id,
                Activity.user_id == user_id,
            )
            .first()
        )

    def get_by_name(
        self, name: str, user_id: str
    ) -> Optional[Activity]:
        """Get an activity by name and verify ownership

        Args:
            name: Activity name
            user_id: User ID to verify ownership

        Returns:
            Activity if found and owned by user, None otherwise
        """
        return (
            self.db.query(Activity)
            .filter(
                Activity.name == name,
                Activity.user_id == user_id,
            )
            .first()
        )

    def list_activities(
        self, user_id: str, skip: int = 0, limit: int = 100
    ) -> List[Activity]:
        """List all activities for a user

        Args:
            user_id: User ID to filter activities
            skip: Number of records to skip
            limit: Maximum number of records to return

        Returns:
            List of activities owned by the user
        """
        return (
            self.db.query(Activity)
            .filter(Activity.user_id == user_id)
            .offset(skip)
            .limit(limit)
            .all()
        )

    def update_activity(
        self,
        activity_id: int,
        user_id: str,
        data: Dict[str, Any],
    ) -> Optional[Activity]:
        """Update an activity

        Args:
            activity_id: Activity ID
            user_id: User ID to verify ownership
            data: Dictionary of fields to update

        Returns:
            Updated Activity if found and owned by user, None otherwise
        """
        activity = self.get_by_user(activity_id, user_id)
        if not activity:
            return None
        return self.update(activity_id, data)

    def delete_activity(
        self, activity_id: int, user_id: str
    ) -> bool:
        """Delete an activity

        Args:
            activity_id: Activity ID
            user_id: User ID to verify ownership

        Returns:
            True if activity was deleted, False if not found or not owned by user
        """
        activity = self.get_by_user(activity_id, user_id)
        if not activity:
            return False
        return self.delete(activity_id)

    def validate_existence(
        self, activity_id: int, user_id: str
    ) -> Activity:
        """Validate activity exists and user owns it

        Args:
            activity_id: Activity ID
            user_id: User ID to verify ownership

        Returns:
            Activity instance if found and owned by user

        Raises:
            HTTPException: If activity not found or access denied
        """
        activity = self.get_by_user(activity_id, user_id)
        if not activity:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Activity not found or access denied",
            )
        return activity

================
File: repositories/BaseRepository.py
================
from typing import Generic, List, Optional, Type, TypeVar
from sqlalchemy.orm import Session
from sqlalchemy.exc import IntegrityError, SQLAlchemyError
from fastapi import HTTPException, status

from .RepositoryMeta import RepositoryMeta

# Type variable for SQLAlchemy model
M = TypeVar("M")
# Type variable for primary key
K = TypeVar("K")


class BaseRepository(RepositoryMeta[M, K], Generic[M, K]):
    """Base repository implementing common CRUD operations with error handling"""

    def __init__(self, db: Session, model: Type[M]):
        """Initialize repository with database session and model class

        Args:
            db: SQLAlchemy database session
            model: SQLAlchemy model class
        """
        self.db = db
        self.model = model

    def create(self, instance: M) -> M:
        """Create a new instance in the database

        Args:
            instance: Model instance to create

        Returns:
            Created model instance

        Raises:
            HTTPException: If database constraints are violated
        """
        try:
            self.db.add(instance)
            self.db.commit()
            self.db.refresh(instance)
            return instance
        except IntegrityError as e:
            self.db.rollback()
            raise HTTPException(
                status_code=status.HTTP_409_CONFLICT,
                detail=f"Resource already exists: {str(e)}",
            )
        except SQLAlchemyError as e:
            self.db.rollback()
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=f"Database error occurred: {str(e)}",
            )

    def get(self, id: K) -> Optional[M]:
        """Get an instance by ID

        Args:
            id: Primary key value

        Returns:
            Model instance if found, None otherwise
        """
        try:
            return (
                self.db.query(self.model)
                .filter(self.model.id == id)
                .first()
            )
        except SQLAlchemyError as e:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=f"Database error occurred: {str(e)}",
            )

    def list(
        self, limit: int = 100, start: int = 0
    ) -> List[M]:
        """List instances with pagination

        Args:
            limit: Maximum number of instances to return
            start: Number of instances to skip

        Returns:
            List of model instances

        Raises:
            HTTPException: If database error occurs
        """
        try:
            return (
                self.db.query(self.model)
                .offset(start)
                .limit(limit)
                .all()
            )
        except SQLAlchemyError as e:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=f"Database error occurred: {str(e)}",
            )

    def update(self, id: K, data: dict) -> Optional[M]:
        """Update an instance by ID

        Args:
            id: Primary key value
            data: Dictionary of attributes to update

        Returns:
            Updated model instance if found, None otherwise

        Raises:
            HTTPException: If database constraints are violated
        """
        try:
            instance = self.get(id)
            if not instance:
                return None

            for key, value in data.items():
                if (
                    hasattr(instance, key)
                    and value is not None
                ):
                    setattr(instance, key, value)

            self.db.commit()
            self.db.refresh(instance)
            return instance
        except IntegrityError as e:
            self.db.rollback()
            raise HTTPException(
                status_code=status.HTTP_409_CONFLICT,
                detail=f"Update violates constraints: {str(e)}",
            )
        except SQLAlchemyError as e:
            self.db.rollback()
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=f"Database error occurred: {str(e)}",
            )

    def delete(self, id: K) -> bool:
        """Delete an instance by ID

        Args:
            id: Primary key value

        Returns:
            True if instance was deleted, False if not found

        Raises:
            HTTPException: If database error occurs
        """
        try:
            instance = self.get(id)
            if not instance:
                return False

            self.db.delete(instance)
            self.db.commit()
            return True
        except SQLAlchemyError as e:
            self.db.rollback()
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=f"Database error occurred: {str(e)}",
            )

    def exists(self, id: K) -> bool:
        """Check if an instance exists

        Args:
            id: Primary key value

        Returns:
            True if instance exists, False otherwise
        """
        return self.get(id) is not None

================
File: repositories/MomentRepository.py
================
from typing import List, Optional, Dict, Any, Union
from datetime import datetime
from sqlalchemy.orm import Session
from sqlalchemy import desc
from fastapi import HTTPException, status

from models.MomentModel import Moment as MomentModel
from models.ActivityModel import Activity
from schemas.pydantic.MomentSchema import (
    MomentList,
    MomentResponse,
)
from .BaseRepository import BaseRepository


class MomentRepository(BaseRepository[MomentModel, int]):
    """Repository for managing Moment entities"""

    def __init__(self, db: Session):
        """Initialize with database session

        Args:
            db: SQLAlchemy database session
        """
        super().__init__(db, MomentModel)

    def create(
        self,
        instance_or_activity_id: Union[MomentModel, int],
        *,  # Force keyword arguments
        data: Optional[dict] = None,
        user_id: Optional[str] = None,
        timestamp: Optional[datetime] = None,
    ) -> MomentModel:
        """Create a new moment

        This method supports two ways of creating a moment:
        1. Passing a MomentModel instance directly
        2. Passing individual fields

        Args:
            instance_or_activity_id: Either a MomentModel instance
                or activity ID
            data: Moment data conforming to activity schema
                (if creating by fields)
            user_id: Owner's user ID (if creating by fields)
            timestamp: Optional timestamp (if creating by fields)

        Returns:
            Created Moment instance
        """
        if isinstance(instance_or_activity_id, MomentModel):
            return super().create(instance_or_activity_id)

        # Create new instance from fields
        moment = MomentModel(
            activity_id=instance_or_activity_id,
            data=data,
            user_id=user_id,
            timestamp=timestamp or datetime.utcnow(),
        )
        return super().create(moment)

    def get_recent_by_user(
        self, user_id: str, limit: int = 5
    ) -> List[MomentModel]:
        """Get recent moments for a user

        Args:
            user_id: User ID to filter moments
            limit: Maximum number of moments to return

        Returns:
            List of recent moments
        """
        return (
            self.db.query(MomentModel)
            .filter(MomentModel.user_id == user_id)
            .order_by(desc(MomentModel.timestamp))
            .limit(limit)
            .all()
        )

    def get_recent_activities(
        self, limit: int = 5
    ) -> List[Activity]:
        """Get recently used activities based on moment timestamps

        Args:
            limit: Maximum number of activities to return

        Returns:
            List of unique activities from recent moments
        """
        return (
            self.db.query(Activity)
            .join(MomentModel)
            .order_by(desc(MomentModel.timestamp))
            .distinct()
            .limit(limit)
            .all()
        )

    def get_activity_moments_count(
        self, activity_id: int
    ) -> int:
        """Get the count of moments for a specific activity

        Args:
            activity_id: Activity ID to count moments for

        Returns:
            Number of moments for the activity
        """
        return (
            self.db.query(MomentModel)
            .filter(MomentModel.activity_id == activity_id)
            .count()
        )

    def list_moments(
        self,
        page: int = 1,
        size: int = 50,
        activity_id: Optional[int] = None,
        start_time: Optional[datetime] = None,
        end_time: Optional[datetime] = None,
        user_id: Optional[str] = None,
    ) -> MomentList:
        """List moments with filtering and pagination

        Args:
            page: Page number (1-based)
            size: Page size
            activity_id: Optional activity ID filter
            start_time: Optional start time filter
            end_time: Optional end time filter
            user_id: Optional user ID filter

        Returns:
            MomentList with pagination metadata
        """
        query = self.db.query(MomentModel).join(Activity)

        # Apply filters
        if activity_id is not None:
            query = query.filter(
                MomentModel.activity_id == activity_id
            )
        if start_time is not None:
            query = query.filter(
                MomentModel.timestamp >= start_time
            )
        if end_time is not None:
            query = query.filter(
                MomentModel.timestamp <= end_time
            )
        if user_id is not None:
            query = query.filter(
                Activity.user_id == user_id
            )

        # Get total count
        total = query.count()

        # Calculate pagination
        pages = (total + size - 1) // size
        skip = (page - 1) * size

        # Get paginated results with activities eager loaded
        moments = (
            query.order_by(desc(MomentModel.timestamp))
            .offset(skip)
            .limit(size)
            .all()
        )

        # Convert to response type
        moment_responses = [
            MomentResponse.from_orm(moment)
            for moment in moments
        ]

        return MomentList(
            items=moment_responses,
            total=total,
            page=page,
            size=size,
            pages=pages,
        )

    def update_moment(
        self, moment_id: int, data: Dict[str, Any]
    ) -> Optional[MomentModel]:
        """Update a moment

        Args:
            moment_id: Moment ID
            data: Dictionary of fields to update

        Returns:
            Updated Moment if found, None otherwise
        """
        return self.update(moment_id, data)

    def delete_moment(self, moment_id: int) -> bool:
        """Delete a moment

        Args:
            moment_id: Moment ID

        Returns:
            True if moment was deleted, False if not found
        """
        return self.delete(moment_id)

    def validate_existence(
        self, moment_id: int
    ) -> MomentModel:
        """Validate that a moment exists

        Args:
            moment_id: Moment ID

        Returns:
            Moment instance if found

        Raises:
            HTTPException: If moment not found
        """
        moment = self.get(moment_id)
        if not moment:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Moment not found",
            )
        return moment

================
File: repositories/RepositoryMeta.py
================
from abc import abstractmethod
from typing import Generic, List, TypeVar

# Type definition for Model
M = TypeVar("M")

# Type definition for Unique Id
K = TypeVar("K")


#################################
# Abstract Class for Repository #
#################################
class RepositoryMeta(Generic[M, K]):

    # Create a new instance of the Model
    @abstractmethod
    def create(self, instance: M) -> M:
        pass

    # Delete an existing instance of the Model
    @abstractmethod
    def delete(self, id: K) -> None:
        pass

    # Fetch an existing instance of the Model by it's unique Id
    @abstractmethod
    def get(self, id: K) -> M:
        pass

    # Lists all existing instance of the Model
    @abstractmethod
    def list(self, limit: int, start: int) -> List[M]:
        pass

    # Updates an existing instance of the Model
    @abstractmethod
    def update(self, id: K, instance: M) -> M:
        pass

================
File: repositories/UserRepository.py
================
from typing import Optional
from sqlalchemy.orm import Session
from models.UserModel import User
from sqlalchemy.exc import IntegrityError
from fastapi import HTTPException, status

from .BaseRepository import BaseRepository


class UserRepository(BaseRepository[User, str]):
    """Repository for managing User entities"""

    def __init__(self, db: Session):
        """Initialize with database session

        Args:
            db: SQLAlchemy database session
        """
        super().__init__(db, User)

    def create_user(
        self, username: str, key_id: str, user_secret: str
    ) -> User:
        """Create a new user

        Args:
            username: Unique username
            key_id: Unique API key ID
            user_secret: Hashed user secret

        Returns:
            Created User instance

        Raises:
            HTTPException: If username exists or key_id collision
        """
        user = User(
            username=username,
            key_id=key_id,
            user_secret=user_secret,
        )
        try:
            return self.create(user)
        except HTTPException as e:
            if e.status_code == status.HTTP_409_CONFLICT:
                # Check specific constraint violation
                if "username" in str(e.detail):
                    raise HTTPException(
                        status_code=status.HTTP_400_BAD_REQUEST,
                        detail="Username already exists",
                    )
                if "key_id" in str(e.detail):
                    raise HTTPException(
                        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                        detail="Key ID collision occurred",
                    )
            raise e

    def get_by_id(self, user_id: str) -> Optional[User]:
        """Get a user by their ID"""
        return (
            self.db.query(User)
            .filter(User.id == user_id)
            .first()
        )

    def get_by_username(
        self, username: str
    ) -> Optional[User]:
        """Get a user by their username

        Args:
            username: Username to lookup

        Returns:
            User if found, None otherwise
        """
        return (
            self.db.query(User)
            .filter(User.username == username)
            .first()
        )

    def get_by_key_id(self, key_id: str) -> Optional[User]:
        """Get a user by their key_id (for API key authentication)

        Args:
            key_id: API key ID to lookup

        Returns:
            User if found, None otherwise
        """
        return (
            self.db.query(User)
            .filter(User.key_id == key_id)
            .first()
        )

================
File: routers/v1/ActivityRouter.py
================
from fastapi import APIRouter, Depends, HTTPException

from services.ActivityService import ActivityService
from schemas.pydantic.ActivitySchema import (
    ActivityCreate,
    ActivityUpdate,
    ActivityResponse,
    ActivityList,
)
from schemas.pydantic.PaginationSchema import (
    PaginationParams,
)
from dependencies import get_current_user
from models.UserModel import User

router = APIRouter(
    prefix="/v1/activities", tags=["activities"]
)


@router.post(
    "", response_model=ActivityResponse, status_code=201
)
async def create_activity(
    activity: ActivityCreate,
    service: ActivityService = Depends(),
    current_user: User = Depends(get_current_user),
):
    """Create a new activity"""
    try:
        return service.create_activity(
            activity, current_user.id
        )
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))


@router.get("", response_model=ActivityList)
async def list_activities(
    pagination: PaginationParams = Depends(),
    service: ActivityService = Depends(),
    current_user: User = Depends(get_current_user),
):
    """List all activities with pagination"""
    return service.list_activities(
        user_id=current_user.id,
        page=pagination.page,
        size=pagination.size,
    )


@router.get(
    "/{activity_id}", response_model=ActivityResponse
)
async def get_activity(
    activity_id: int,
    service: ActivityService = Depends(),
    current_user: User = Depends(get_current_user),
):
    """Get an activity by ID"""
    activity = service.get_activity(
        activity_id, current_user.id
    )
    if not activity:
        raise HTTPException(
            status_code=404,
            detail="Activity not found",
        )
    return activity


@router.put(
    "/{activity_id}", response_model=ActivityResponse
)
async def update_activity(
    activity_id: int,
    activity: ActivityUpdate,
    service: ActivityService = Depends(),
    current_user: User = Depends(get_current_user),
):
    """Update an activity"""
    updated = service.update_activity(
        activity_id,
        activity,
        current_user.id,
    )
    if not updated:
        raise HTTPException(
            status_code=404,
            detail="Activity not found",
        )
    return updated


@router.delete("/{activity_id}")
async def delete_activity(
    activity_id: int,
    service: ActivityService = Depends(),
    current_user: User = Depends(get_current_user),
):
    """Delete an activity"""
    if not service.delete_activity(
        activity_id, current_user.id
    ):
        raise HTTPException(
            status_code=404,
            detail="Activity not found",
        )
    return {"message": "Activity deleted successfully"}

================
File: routers/v1/AuthRouter.py
================
from fastapi import (
    APIRouter,
    Depends,
    HTTPException,
    status,
)
from sqlalchemy.orm import Session
from configs.Database import get_db_connection
from services.UserService import UserService
from schemas.pydantic.UserSchema import (
    UserCreate,
    UserRegisterResponse,
    UserLoginRequest,
    Token,
)
from utils.security import create_access_token
from datetime import timedelta

router = APIRouter(prefix="/v1/auth", tags=["auth"])


@router.post(
    "/register",
    response_model=UserRegisterResponse,
    status_code=status.HTTP_201_CREATED,
)
def register_user(
    request: UserCreate,
    db: Session = Depends(get_db_connection),
):
    """Register a new user"""
    service = UserService(db)
    try:
        user, user_secret = service.register_user(
            username=request.username
        )
        return {
            "id": user.id,
            "username": user.username,
            "user_secret": user_secret,  # Return the plain user_secret
        }
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e),
        )


@router.post("/token", response_model=Token)
async def login_for_access_token(
    request: UserLoginRequest,
    db: Session = Depends(get_db_connection),
):
    """Login to get an access token"""
    service = UserService(db)
    try:
        user = service.authenticate_user(
            request.user_secret
        )

        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Incorrect username or password",
                headers={"WWW-Authenticate": "Bearer"},
            )

        # Create access token with user ID as subject
        access_token = create_access_token(
            data={"sub": user.id},
            expires_delta=timedelta(minutes=30),
        )

        return {
            "access_token": access_token,
            "token_type": "bearer",
        }
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e),
        )

================
File: routers/v1/MomentRouter.py
================
from typing import List, Optional
from datetime import datetime
from fastapi import APIRouter, Depends, Query

from schemas.pydantic.MomentSchema import (
    MomentResponse,
    MomentCreate,
    MomentUpdate,
    MomentList,
)
from schemas.pydantic.PaginationSchema import (
    PaginationParams,
)
from services.MomentService import MomentService
from dependencies import get_current_user
from models.UserModel import User

router = APIRouter(prefix="/v1/moments", tags=["moments"])


@router.post(
    "", response_model=MomentResponse, status_code=201
)
async def create_moment(
    moment: MomentCreate,
    service: MomentService = Depends(),
    current_user: User = Depends(get_current_user),
):
    """Create a new moment"""
    return service.create_moment(moment, current_user.id)


@router.get("", response_model=MomentList)
async def list_moments(
    pagination: PaginationParams = Depends(),
    activity_id: Optional[int] = None,
    start_date: Optional[datetime] = None,
    end_date: Optional[datetime] = None,
    service: MomentService = Depends(),
    current_user: User = Depends(get_current_user),
):
    """
    List moments with filtering and pagination
    - activity_id: Filter by activity
    - start_date: Filter moments after this time (UTC)
    - end_date: Filter moments before this time (UTC)
    """
    return service.list_moments(
        page=pagination.page,
        size=pagination.size,
        activity_id=activity_id,
        start_date=start_date,
        end_date=end_date,
        user_id=current_user.id,
    )


@router.get("/{moment_id}", response_model=MomentResponse)
async def get_moment(
    moment_id: int,
    service: MomentService = Depends(),
    current_user: User = Depends(get_current_user),
):
    """Get a moment by ID"""
    return service.get_moment(moment_id, current_user.id)


@router.put("/{moment_id}", response_model=MomentResponse)
async def update_moment(
    moment_id: int,
    moment: MomentUpdate,
    service: MomentService = Depends(),
    current_user: User = Depends(get_current_user),
):
    """Update a moment"""
    return service.update_moment(
        moment_id, moment, current_user.id
    )


@router.delete("/{moment_id}", status_code=204)
async def delete_moment(
    moment_id: int,
    service: MomentService = Depends(),
    current_user: User = Depends(get_current_user),
):
    """Delete a moment"""
    service.delete_moment(moment_id, current_user.id)
    return None


@router.get("/activities/recent", response_model=List[dict])
async def get_recent_activities(
    limit: int = Query(5, ge=1, le=20),
    service: MomentService = Depends(),
    current_user: User = Depends(get_current_user),
):
    """Get recently used activities"""
    return service.list_recent_activities(
        str(current_user.id), limit
    )

================
File: schemas/base/activity_schema.py
================
from typing import Dict, Optional, List
from dataclasses import dataclass
import re
from utils.json_utils import ensure_dict, ensure_string


@dataclass
class ActivityData:
    """
    Base data structure for activity data, works with Python dicts internally.
    """

    name: str
    description: str
    activity_schema: Dict
    icon: str
    color: str
    id: Optional[int] = None
    user_id: Optional[str] = None
    moment_count: Optional[int] = None
    moments: Optional[List[Dict]] = None

    def __post_init__(self):
        """Validate data after initialization"""
        self.validate()

    def validate(self) -> None:
        """Validate the activity data"""
        # Name validation
        if not isinstance(self.name, str):
            raise ValueError("name must be a string")
        if len(self.name) < 1 or len(self.name) > 255:
            raise ValueError(
                "name must be between 1 and 255 characters"
            )

        # Description validation
        if not isinstance(self.description, str):
            raise ValueError("description must be a string")
        if (
            len(self.description) < 1
            or len(self.description) > 1000
        ):
            raise ValueError(
                "description must be between 1 and 1000 characters"
            )

        # Activity schema validation
        if not isinstance(self.activity_schema, dict):
            raise ValueError(
                "activity_schema must be a dictionary"
            )
        # Could add JSON Schema validation here if needed

        # Icon validation
        if not isinstance(self.icon, str):
            raise ValueError("icon must be a string")
        if len(self.icon) < 1 or len(self.icon) > 255:
            raise ValueError(
                "icon must be between 1 and 255 characters"
            )

        # Color validation
        if not isinstance(self.color, str):
            raise ValueError("color must be a string")
        if not re.match(r"^#[0-9A-Fa-f]{6}$", self.color):
            raise ValueError(
                "color must be a valid hex color code (e.g., #4A90E2)"
            )

        # ID validation
        if self.id is not None:
            if not isinstance(self.id, int) or self.id <= 0:
                raise ValueError(
                    "id must be a positive integer"
                )

        # User ID validation
        if self.user_id is not None:
            if not isinstance(self.user_id, str):
                raise ValueError("user_id must be a string")

        # Moment count validation
        if self.moment_count is not None:
            if (
                not isinstance(self.moment_count, int)
                or self.moment_count < 0
            ):
                raise ValueError(
                    "moment_count must be a non-negative integer"
                )

    @classmethod
    def from_dict(cls, data: Dict) -> "ActivityData":
        """Create from a dictionary (used by both Pydantic and GraphQL)"""
        if not isinstance(data, dict):
            raise ValueError("Input must be a dictionary")

        required_fields = [
            "name",
            "description",
            "activity_schema",
            "icon",
            "color",
        ]
        for field in required_fields:
            snake_case = field
            camel_case = field[0].lower() + field[
                1:
            ].replace("_", "")
            if (
                snake_case not in data
                and camel_case not in data
            ):
                raise ValueError(f"{field} is required")

        return cls(
            name=data["name"],
            description=data["description"],
            activity_schema=ensure_dict(
                data.get("activity_schema")
                or data.get("activitySchema", {})
            ),
            icon=data["icon"],
            color=data["color"],
            id=data.get("id"),
            user_id=data.get("user_id")
            or data.get("userId"),
            moment_count=data.get("moment_count")
            or data.get("momentCount", 0),
            moments=data.get("moments", []),
        )

    def to_dict(self, graphql: bool = False) -> Dict:
        """Convert to dictionary, optionally using GraphQL field naming"""
        if graphql:
            base = {
                "name": self.name,
                "description": self.description,
                "activitySchema": ensure_string(
                    self.activity_schema
                ),
                "icon": self.icon,
                "color": self.color,
                "momentCount": self.moment_count or 0,
            }
            if self.user_id:
                base["userId"] = self.user_id
        else:
            base = {
                "name": self.name,
                "description": self.description,
                "activity_schema": self.activity_schema,
                "icon": self.icon,
                "color": self.color,
                "moment_count": self.moment_count or 0,
            }
            if self.user_id:
                base["user_id"] = self.user_id

        if self.id is not None:
            base["id"] = self.id

        return base

    def to_json_dict(self, graphql: bool = False) -> Dict:
        """Convert to dictionary with JSON strings for schema"""
        result = self.to_dict(graphql)
        if graphql:
            result["activitySchema"] = ensure_string(
                self.activity_schema
            )
        else:
            result["activity_schema"] = ensure_string(
                self.activity_schema
            )
        return result

================
File: schemas/base/moment_schema.py
================
from typing import Dict, Optional
from datetime import datetime
from dataclasses import dataclass
from utils.json_utils import ensure_dict, ensure_string


@dataclass
class MomentData:
    """Base data struct for moment data, works with Python dicts internally"""

    activity_id: int
    data: Dict
    timestamp: Optional[datetime] = None
    id: Optional[int] = None
    user_id: Optional[str] = None

    def __post_init__(self):
        """Validate data after initialization"""
        self.validate()

    def validate(self) -> None:
        """Validate the moment data"""
        if (
            not isinstance(self.activity_id, int)
            or self.activity_id <= 0
        ):
            raise ValueError(
                "activity_id must be a positive integer"
            )

        if not isinstance(self.data, dict):
            raise ValueError("data must be a dictionary")

        if self.timestamp is not None and not isinstance(
            self.timestamp, datetime
        ):
            raise ValueError(
                "timestamp must be a datetime object"
            )

        if self.id is not None and (
            not isinstance(self.id, int) or self.id <= 0
        ):
            raise ValueError(
                "id must be a positive integer"
            )

    @classmethod
    def from_dict(cls, data: Dict) -> "MomentData":
        """Create from a dictionary (used by both Pydantic and GraphQL)"""
        activity_id = data.get("activity_id") or data.get(
            "activityId"
        )
        if not activity_id:
            raise ValueError("activity_id is required")

        return cls(
            activity_id=activity_id,
            data=ensure_dict(data.get("data", {})),
            timestamp=data.get("timestamp")
            or datetime.utcnow(),
            id=data.get("id"),
            user_id=data.get("user_id")
            or data.get("userId"),
        )

    def to_dict(self, graphql: bool = False) -> Dict:
        """Convert to dictionary, optionally using GraphQL field naming"""
        base = {
            "data": ensure_dict(self.data),
            "timestamp": self.timestamp
            or datetime.utcnow(),
        }

        if graphql:
            base.update(
                {
                    "activityId": self.activity_id,
                    "userId": self.user_id,
                }
            )
        else:
            base.update(
                {
                    "activity_id": self.activity_id,
                    "user_id": self.user_id,
                }
            )

        if self.id is not None:
            base["id"] = self.id

        return base

    def to_json_dict(self, graphql: bool = False) -> Dict:
        """Convert to dictionary with JSON string for data field"""
        result = self.to_dict(graphql)
        result["data"] = ensure_string(result["data"])
        return result

================
File: schemas/base/user_schema.py
================
from typing import Optional, Dict
from datetime import datetime
from dataclasses import dataclass
import re


@dataclass
class UserData:
    """Base data structure for user data"""

    username: str
    id: Optional[str] = None
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None
    user_secret: Optional[str] = (
        None  # Only used during registration
    )

    def __post_init__(self):
        """Validate data after initialization"""
        self.validate()

    def validate(self) -> None:
        """Validate the user data"""
        # Username validation
        if not isinstance(self.username, str):
            raise ValueError("username must be a string")

        if not re.match(r"^[a-zA-Z0-9_-]+$", self.username):
            raise ValueError(
                "username can only have letters, numbers, underscores, hyphens"
            )

        if (
            len(self.username) < 3
            or len(self.username) > 50
        ):
            raise ValueError(
                "username must be between 3 and 50 characters"
            )

        # ID validation
        if self.id is not None:
            if not isinstance(self.id, str):
                raise ValueError("id must be a string")
            if not self.id.strip():
                raise ValueError(
                    "id cannot be empty if provided"
                )

        # Timestamp validation
        if self.created_at is not None:
            if not isinstance(self.created_at, datetime):
                raise ValueError(
                    "created_at must be a datetime object"
                )

        if self.updated_at is not None:
            if not isinstance(self.updated_at, datetime):
                raise ValueError(
                    "updated_at must be a datetime object"
                )
            if (
                self.created_at
                and self.updated_at < self.created_at
            ):
                raise ValueError(
                    "updated_at cannot be earlier than created_at"
                )

        # User secret validation
        if self.user_secret is not None:
            if not isinstance(self.user_secret, str):
                raise ValueError(
                    "user_secret must be a string"
                )
            if len(self.user_secret) < 32:
                raise ValueError(
                    "user_secret must be at least 32 characters"
                )

    @classmethod
    def from_dict(cls, data: Dict) -> "UserData":
        """Create from a dictionary (used by both Pydantic and GraphQL)"""
        if not isinstance(data, dict):
            raise ValueError("Input must be a dictionary")

        if "username" not in data:
            raise ValueError("username is required")

        return cls(
            username=data["username"],
            id=data.get("id"),
            created_at=data.get("created_at")
            or data.get("createdAt"),
            updated_at=data.get("updated_at")
            or data.get("updatedAt"),
            user_secret=data.get("user_secret")
            or data.get("userSecret"),
        )

    def to_dict(
        self,
        graphql: bool = False,
        include_secret: bool = False,
    ) -> Dict:
        """
        Convert to dictionary, optionally using GraphQL field naming

        Args:
            graphql: Whether to use GraphQL field naming
            include_secret: Whether to include the user_secret (registration)
        """
        if graphql:
            base = {
                "username": self.username,
                "createdAt": self.created_at,
                "updatedAt": self.updated_at,
            }
            if include_secret and self.user_secret:
                base["userSecret"] = self.user_secret
        else:
            base = {
                "username": self.username,
                "created_at": self.created_at,
                "updated_at": self.updated_at,
            }
            if include_secret and self.user_secret:
                base["user_secret"] = self.user_secret

        if self.id is not None:
            base["id"] = self.id

        return base

    def to_auth_dict(self) -> Dict:
        """Convert to dictionary for authentication purposes"""
        if not self.id:
            raise ValueError(
                "Cannot create auth dict without user id"
            )

        return {"id": self.id, "username": self.username}

================
File: schemas/graphql/mutations/ActivityMutation.py
================
import strawberry
from fastapi import HTTPException

from schemas.pydantic.ActivitySchema import (
    ActivityCreate,
    ActivityUpdate,
)
from schemas.graphql.types.Activity import (
    Activity,
    ActivityInput,
    ActivityUpdateInput,
)
from configs.GraphQL import (
    get_ActivityService,
    get_user_from_context,
)


@strawberry.type
class ActivityMutation:
    @strawberry.mutation
    async def create_activity(
        self, info: strawberry.Info, activity: ActivityInput
    ) -> Activity:
        """Create a new activity

        Args:
            info: GraphQL request info containing context
            activity: Activity input data

        Returns:
            Created activity

        Raises:
            Exception: If user is not authenticated or validation fails
        """
        current_user = get_user_from_context(info)
        if not current_user:
            raise HTTPException(
                status_code=401,
                detail="Authentication required to create activity",
            )

        service = get_ActivityService(info)
        activity_create = ActivityCreate(
            **activity.to_dict()
        )

        try:
            db_activity = service.create_activity_graphql(
                activity_data=activity_create,
                user_id=str(current_user.id),
            )
            return Activity.from_db(db_activity)
        except ValueError as e:
            raise HTTPException(
                status_code=400,
                detail=f"Invalid activity data: {str(e)}",
            )

    @strawberry.mutation
    async def update_activity(
        self,
        info: strawberry.Info,
        activity_id: int,
        activity: ActivityUpdateInput,
    ) -> Activity:
        """Update an existing activity

        Args:
            info: GraphQL request info containing context
            activity_id: ID of activity to update
            activity: Updated activity data

        Returns:
            Updated activity

        Raises:
            Exception: If user is not authenticated or validation fails
        """
        current_user = get_user_from_context(info)
        if not current_user:
            raise HTTPException(
                status_code=401,
                detail="Authentication required to update activity",
            )

        service = get_ActivityService(info)
        activity_data = ActivityUpdate(**activity.to_dict())

        try:
            db_activity = service.update_activity_graphql(
                activity_id=activity_id,
                activity_data=activity_data,
                user_id=str(current_user.id),
            )
            return Activity.from_db(db_activity)
        except ValueError as e:
            raise HTTPException(
                status_code=400,
                detail=f"Invalid activity data: {str(e)}",
            )

    @strawberry.mutation
    async def delete_activity(
        self, info: strawberry.Info, activity_id: int
    ) -> bool:
        """Delete an activity

        Args:
            info: GraphQL request info containing context
            activity_id: ID of activity to delete

        Returns:
            True if deletion was successful

        Raises:
            Exception: If user is not authenticated or activity not found
        """
        current_user = get_user_from_context(info)
        if not current_user:
            raise HTTPException(
                status_code=401,
                detail="Authentication required to delete activity",
            )

        service = get_ActivityService(info)
        try:
            return service.delete_activity(
                activity_id=activity_id,
                user_id=str(current_user.id),
            )
        except ValueError as e:
            raise HTTPException(
                status_code=404,
                detail=f"Activity not found: {str(e)}",
            )

================
File: schemas/graphql/mutations/MomentMutation.py
================
import strawberry
from strawberry.types import Info
from fastapi import HTTPException

from ..types.Moment import Moment, MomentInput
from schemas.pydantic.MomentSchema import (
    MomentUpdate,
)
from configs.GraphQL import (
    get_MomentService,
    get_user_from_context,
)


@strawberry.type
class MomentMutation:
    @strawberry.mutation
    async def create_moment(
        self, info: Info, moment: MomentInput
    ) -> Moment:
        """Create a new moment"""
        current_user = get_user_from_context(info)
        if not current_user:
            raise HTTPException(
                status_code=401, detail="Unauthorized"
            )
        service = get_MomentService(info)

        # Convert the input to domain model
        moment_data = moment.to_domain()
        db_moment = service.create_moment(
            moment_data=moment_data, user_id=current_user.id
        )
        return Moment.from_db(db_moment)

    @strawberry.mutation
    async def update_moment(
        self,
        info: Info,
        moment_id: int,
        moment: MomentInput,
    ) -> Moment:
        """Update a moment"""
        current_user = get_user_from_context(info)
        if not current_user:
            raise HTTPException(
                status_code=401, detail="Unauthorized"
            )
        service = get_MomentService(info)

        # Convert the input to domain model
        moment_data = moment.to_domain()
        db_moment = service.update_moment(
            moment_id=moment_id,
            moment_data=MomentUpdate(
                data=moment_data.data,
                timestamp=moment_data.timestamp,
            ),
            user_id=current_user.id,
        )
        return Moment.from_db(db_moment)

================
File: schemas/graphql/mutations/UserMutation.py
================
import strawberry
from services.UserService import UserService
from schemas.graphql.types.User import (
    UserCreateInput,
    UserLoginInput,
    UserRegisterResponse,
    Token,
)
from typing import cast
from datetime import datetime


@strawberry.type
class UserMutation:
    @strawberry.mutation
    def register_user(
        self,
        input: UserCreateInput,
        info: strawberry.types.Info,
    ) -> UserRegisterResponse:
        """Register a new user"""
        db = info.context["db"]
        service = UserService(db)
        user, user_secret = service.register_user(
            input.username
        )
        return UserRegisterResponse(
            id=cast(str, user.id),
            username=cast(str, user.username),
            userSecret=user_secret,
            createdAt=cast(datetime, user.created_at),
            updatedAt=cast(
                datetime | None, user.updated_at
            ),
        )

    @strawberry.mutation
    def login(
        self,
        input: UserLoginInput,
        info: strawberry.types.Info,
    ) -> Token:
        """Login to get an access token"""
        db = info.context["db"]
        service = UserService(db)
        user = service.authenticate_user(input.userSecret)
        from utils.security import create_access_token

        access_token = create_access_token(
            data={"sub": user.id}
        )
        return Token(accessToken=access_token)

================
File: schemas/graphql/types/Activity.py
================
import strawberry
from typing import List, Optional, Dict, Any
from schemas.base.activity_schema import ActivityData
from utils.json_utils import ensure_dict
from .Moment import Moment


@strawberry.type
class Activity:
    """Activity type for GraphQL queries"""

    @strawberry.field(
        description="Unique identifier for the activity"
    )
    def id(self) -> int:
        return self._id

    @strawberry.field(description="Name of the activity")
    def name(self) -> str:
        return self._name

    @strawberry.field(
        description="Detailed description of the activity"
    )
    def description(self) -> str:
        return self._description

    @strawberry.field(
        description="JSON Schema defining the structure of moment data"
    )
    def activitySchema(self) -> str:
        return self._activity_schema

    @strawberry.field(
        description="Icon identifier for the activity"
    )
    def icon(self) -> str:
        return self._icon

    @strawberry.field(
        description="Color code for the activity (hex format)"
    )
    def color(self) -> str:
        return self._color

    @strawberry.field(
        description="Number of moments using this activity",
    )
    def momentCount(self) -> int:
        return self._moment_count

    @strawberry.field(
        description="Moments using this activity",
    )
    def moments(self) -> List[Moment]:
        return self._moments

    def __init__(
        self,
        id: int,
        name: str,
        description: str,
        activitySchema: str,
        icon: str,
        color: str,
        momentCount: int = 0,
        moments: Optional[List[Moment]] = None,
    ):
        self._id = id
        self._name = name
        self._description = description
        self._activity_schema = activitySchema
        self._icon = icon
        self._color = color
        self._moment_count = momentCount
        self._moments = moments or []

    @classmethod
    def from_domain(
        cls, activity: ActivityData
    ) -> "Activity":
        """Create from domain model"""
        activity_dict = activity.to_json_dict(graphql=True)
        return cls(
            id=activity_dict["id"],
            name=activity_dict["name"],
            description=activity_dict["description"],
            activitySchema=activity_dict["activitySchema"],
            icon=activity_dict["icon"],
            color=activity_dict["color"],
            momentCount=activity_dict["momentCount"],
            moments=[],  # Lazy load moments
        )

    @classmethod
    def from_db(cls, db_activity: Any) -> "Activity":
        """Create from database model"""
        return cls.from_domain(
            ActivityData.from_dict(
                {
                    "id": db_activity.id,
                    "name": db_activity.name,
                    "description": db_activity.description,
                    "activity_schema": db_activity.activity_schema,
                    "icon": db_activity.icon,
                    "color": db_activity.color,
                    "moment_count": getattr(
                        db_activity, "moment_count", 0
                    ),
                }
            )
        )


@strawberry.input
class ActivityInput:
    """Input type for creating a new activity"""

    name: str = strawberry.field(
        description="Name of the activity (1-255 characters)"
    )
    description: str = strawberry.field(
        description="Detailed description (1-1000 characters)"
    )
    activitySchema: str = strawberry.field(
        description="JSON Schema defining the structure of moment data"
    )
    icon: str = strawberry.field(
        description="Icon identifier (1-255 characters)"
    )
    color: str = strawberry.field(
        description="Color code in hex format (e.g., #4A90E2)"
    )

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for Pydantic model creation"""
        return {
            "name": self.name,
            "description": self.description,
            "activity_schema": ensure_dict(
                self.activitySchema
            ),
            "icon": self.icon,
            "color": self.color,
        }

    def to_domain(self) -> ActivityData:
        """Convert to domain model"""
        return ActivityData.from_dict(self.to_dict())


@strawberry.input
class ActivityUpdateInput:
    """Input type for updating an activity"""

    name: Optional[str] = strawberry.field(
        default=None,
        description="Name of the activity (1-255 characters)",
    )
    description: Optional[str] = strawberry.field(
        default=None,
        description="Detailed description (1-1000 characters)",
    )
    activitySchema: Optional[str] = strawberry.field(
        default=None,
        description="JSON Schema defining the structure of moment data",
    )
    icon: Optional[str] = strawberry.field(
        default=None,
        description="Icon identifier (1-255 characters)",
    )
    color: Optional[str] = strawberry.field(
        default=None,
        description="Color code in hex format (e.g., #4A90E2)",
    )

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for Pydantic model creation"""
        update_dict: Dict[str, Any] = {}
        if self.name is not None:
            update_dict["name"] = self.name
        if self.description is not None:
            update_dict["description"] = self.description
        if self.activitySchema is not None:
            update_dict["activity_schema"] = ensure_dict(
                self.activitySchema
            )
        if self.icon is not None:
            update_dict["icon"] = self.icon
        if self.color is not None:
            update_dict["color"] = self.color
        return update_dict

    def to_domain(
        self, existing: ActivityData
    ) -> ActivityData:
        """Convert to domain model, preserving existing data"""
        existing_dict = existing.to_dict()
        existing_dict.update(self.to_dict())
        return ActivityData.from_dict(existing_dict)


@strawberry.type
class ActivityConnection:
    """Type for paginated activity lists"""

    @strawberry.field(description="List of activities")
    def items(self) -> List[Activity]:
        return self._items

    @strawberry.field(description="Total number of items")
    def total(self) -> int:
        return self._total

    @strawberry.field(description="Current page number")
    def page(self) -> int:
        return self._page

    @strawberry.field(
        description="Number of items per page"
    )
    def size(self) -> int:
        return self._size

    @strawberry.field(description="Total number of pages")
    def pages(self) -> int:
        return (self._total + self._size - 1) // self._size

    def __init__(
        self,
        items: List[Activity],
        total: int,
        page: int = 1,
        size: int = 50,
    ):
        self._items = items
        self._total = total
        self._page = page
        self._size = size

    @classmethod
    def from_pydantic(
        cls, activity_list: Any
    ) -> "ActivityConnection":
        """Convert pydantic ActivityList to GraphQL ActivityConnection"""
        return cls(
            items=[
                Activity.from_db(item)
                for item in activity_list.items
            ],
            total=activity_list.total,
            page=activity_list.page,
            size=activity_list.size,
        )

================
File: schemas/graphql/types/Moment.py
================
import strawberry
from typing import Optional, Any, List
from datetime import datetime
from schemas.base.moment_schema import MomentData


@strawberry.type
class Moment:
    """Type for moment data in GraphQL"""

    @strawberry.field(
        description="Unique identifier for the moment"
    )
    def id(self) -> int:
        return self._id

    @strawberry.field(
        description="ID of the activity this moment belongs to"
    )
    def activityId(self) -> int:
        return self._activity_id

    @strawberry.field(
        description="JSON string for the moment data"
    )
    def data(self) -> str:
        return self._data

    @strawberry.field(
        description="UTC timestamp for the moment"
    )
    def timestamp(self) -> datetime:
        return self._timestamp

    @strawberry.field(
        description="ID of the user who created this moment"
    )
    def userId(self) -> Optional[str]:
        return self._user_id

    def __init__(
        self,
        id: int,
        activityId: int,
        data: str,
        timestamp: datetime,
        userId: Optional[str] = None,
    ):
        self._id = id
        self._activity_id = activityId
        self._data = data
        self._timestamp = timestamp
        self._user_id = userId

    @classmethod
    def from_domain(cls, moment: MomentData) -> "Moment":
        """Create from domain model"""
        moment_dict = moment.to_json_dict(graphql=True)
        return cls(
            id=moment_dict["id"],
            activityId=moment_dict["activityId"],
            data=moment_dict["data"],
            timestamp=moment_dict["timestamp"],
            userId=moment_dict.get("userId"),
        )

    @classmethod
    def from_db(cls, db_moment: Any) -> "Moment":
        """Create from database model"""
        return cls.from_domain(
            MomentData.from_dict(
                {
                    "id": db_moment.id,
                    "activity_id": db_moment.activity_id,
                    "data": db_moment.data,
                    "timestamp": db_moment.timestamp,
                    "user_id": db_moment.user_id,
                }
            )
        )


@strawberry.type
class MomentConnection:
    """Type for paginated moment lists"""

    @strawberry.field(description="List of moments")
    def items(self) -> List[Moment]:
        return self._items

    @strawberry.field(description="Total number of items")
    def total(self) -> int:
        return self._total

    @strawberry.field(description="Current page number")
    def page(self) -> int:
        return self._page

    @strawberry.field(
        description="Number of items per page"
    )
    def size(self) -> int:
        return self._size

    @strawberry.field(description="Total number of pages")
    def pages(self) -> int:
        return self._pages

    def __init__(
        self,
        items: List[Moment],
        total: int,
        page: int = 1,
        size: int = 50,
    ):
        self._items = items
        self._total = total
        self._page = page
        self._size = size
        self._pages = (total + size - 1) // size

    @classmethod
    def from_pydantic(
        cls, moment_list: Any
    ) -> "MomentConnection":
        """Create from pydantic MomentList"""
        return cls(
            items=[
                Moment.from_db(moment)
                for moment in moment_list.items
            ],
            total=moment_list.total,
            page=moment_list.page,
            size=moment_list.size,
        )


@strawberry.input
class MomentInput:
    """Input type for creating a new moment"""

    activityId: int = strawberry.field(
        description="ID of the activity this moment belongs to"
    )
    data: str = strawberry.field(
        description="JSON string for the moment data"
    )
    timestamp: Optional[datetime] = strawberry.field(
        default=None,
        description="UTC timestamp for the moment",
    )

    def to_domain(self) -> MomentData:
        """Convert to domain model"""
        return MomentData.from_dict(
            {
                "activity_id": self.activityId,
                "data": self.data,  # Will be converted to dict by MomentData
                "timestamp": self.timestamp,
            }
        )

================
File: schemas/graphql/types/User.py
================
from datetime import datetime
import strawberry
from typing import Optional
from schemas.base.user_schema import UserData


@strawberry.type
class User:
    """User type for GraphQL queries"""

    @strawberry.field(
        description="Unique identifier for the user"
    )
    def id(self) -> str:
        return self._id

    @strawberry.field(description="User's unique username")
    def username(self) -> str:
        return self._username

    @strawberry.field(
        description="When the user was created"
    )
    def createdAt(self) -> datetime:
        return self._created_at

    @strawberry.field(
        description="When the user was last updated"
    )
    def updatedAt(self) -> Optional[datetime]:
        return self._updated_at

    def __init__(
        self,
        id: str,
        username: str,
        createdAt: datetime,
        updatedAt: Optional[datetime] = None,
    ):
        self._id = id
        self._username = username
        self._created_at = createdAt
        self._updated_at = updatedAt

    @classmethod
    def from_domain(cls, user: UserData) -> "User":
        """Create from domain model"""
        user_dict = user.to_dict(graphql=True)
        return cls(
            id=user_dict["id"],
            username=user_dict["username"],
            createdAt=user_dict["createdAt"],
            updatedAt=user_dict["updatedAt"],
        )


@strawberry.type
class UserRegisterResponse:
    """Response type for user registration"""

    @strawberry.field(
        description="Unique identifier for the user"
    )
    def id(self) -> str:
        return self._id

    @strawberry.field(description="User's unique username")
    def username(self) -> str:
        return self._username

    @strawberry.field(
        description="Secret key for authentication (provided in registration)"
    )
    def userSecret(self) -> str:
        return self._user_secret

    @strawberry.field(
        description="When the user was created"
    )
    def createdAt(self) -> datetime:
        return self._created_at

    @strawberry.field(
        description="When the user was last updated"
    )
    def updatedAt(self) -> Optional[datetime]:
        return self._updated_at

    def __init__(
        self,
        id: str,
        username: str,
        userSecret: str,
        createdAt: datetime,
        updatedAt: Optional[datetime] = None,
    ):
        self._id = id
        self._username = username
        self._user_secret = userSecret
        self._created_at = createdAt
        self._updated_at = updatedAt

    @classmethod
    def from_domain(
        cls, user: UserData
    ) -> "UserRegisterResponse":
        """Create from domain model"""
        user_dict = user.to_dict(
            graphql=True, include_secret=True
        )
        return cls(
            id=user_dict["id"],
            username=user_dict["username"],
            userSecret=user_dict["userSecret"],
            createdAt=user_dict["createdAt"],
            updatedAt=user_dict["updatedAt"],
        )


@strawberry.input
class UserCreateInput:
    """Input type for creating a new user"""

    username: str = strawberry.field(
        description="Username must be 3-50 characters and contain only "
        "letters, numbers, underscores, and hyphens"
    )

    def to_domain(self) -> UserData:
        """Convert to domain model"""
        return UserData.from_dict(
            {"username": self.username}
        )


@strawberry.input
class UserLoginInput:
    """Input type for user login"""

    userSecret: str = strawberry.field(
        description="User's secret key for authentication"
    )


@strawberry.type
class Token:
    """Authentication token response"""

    @strawberry.field(description="JWT access token")
    def accessToken(self) -> str:
        return self._access_token

    @strawberry.field(
        description="Token type (always 'bearer')"
    )
    def tokenType(self) -> str:
        return self._token_type

    def __init__(
        self,
        accessToken: str,
        tokenType: str = "bearer",
    ):
        self._access_token = accessToken
        self._token_type = tokenType

================
File: schemas/graphql/Mutation.py
================
import strawberry
from schemas.graphql.mutations.UserMutation import (
    UserMutation,
)
from schemas.graphql.mutations.ActivityMutation import (
    ActivityMutation,
)
from schemas.graphql.mutations.MomentMutation import (
    MomentMutation,
)


@strawberry.type(description="Mutate all entities")
class Mutation(
    UserMutation, ActivityMutation, MomentMutation
):
    """Root mutation type that inherits
    all mutations from specific mutation types"""

    pass

================
File: schemas/graphql/Query.py
================
from typing import List, Optional
from datetime import datetime

import strawberry
from strawberry.types import Info
from fastapi import HTTPException
from configs.GraphQL import (
    get_ActivityService,
    get_MomentService,
    get_user_from_context,
)

from schemas.graphql.types.Activity import (
    Activity,
    ActivityConnection,
)
from schemas.graphql.types.Moment import (
    Moment,
    MomentConnection,
)


@strawberry.type(description="Query all entities")
class Query:
    @strawberry.field(description="Get an Activity by ID")
    def getActivity(
        self, id: int, info: Info
    ) -> Optional[Activity]:
        """Get an activity by ID

        Args:
            id: Activity ID
            info: GraphQL request info

        Returns:
            Activity if found, None otherwise

        Raises:
            HTTPException: If user is not authenticated
        """
        activity_service = get_ActivityService(info)
        user = get_user_from_context(info)
        if not user:
            raise HTTPException(
                status_code=401,
                detail="Authentication required to get activity",
            )
        return activity_service.get_activity_graphql(
            id, str(user.id)
        )

    @strawberry.field(description="List all Activities")
    def getActivities(
        self,
        info: Info,
        page: int = 1,
        size: int = 50,
    ) -> ActivityConnection:
        """List all activities with pagination

        Args:
            info: GraphQL request info
            page: Page number (1-based)
            size: Items per page

        Returns:
            Paginated list of activities

        Raises:
            HTTPException: If user is not authenticated
        """
        activity_service = get_ActivityService(info)
        user = get_user_from_context(info)
        if not user:
            raise HTTPException(
                status_code=401,
                detail="Authentication required to list activities",
            )

        activities = activity_service.list_activities(
            user_id=str(user.id),
            page=page,
            size=size,
        )

        return ActivityConnection(
            items=activities,
            total=len(activities),
            page=page,
            size=size,
        )

    @strawberry.field(description="Get a moment by ID")
    def getMoment(
        self, id: int, info: Info
    ) -> Optional[Moment]:
        """Get a moment by ID

        Args:
            id: Moment ID
            info: GraphQL request info

        Returns:
            Moment if found, None otherwise

        Raises:
            HTTPException: If user is not authenticated
        """
        moment_service = get_MomentService(info)
        user = get_user_from_context(info)
        if not user:
            raise HTTPException(
                status_code=401,
                detail="Authentication required to get moment",
            )
        return moment_service.get_moment_graphql(
            id, str(user.id)
        )

    @strawberry.field(
        description="Get moments with pagination"
    )
    def getMoments(
        self,
        info: Info,
        page: int = 1,
        size: int = 50,
        activity_id: Optional[int] = None,
        start_time: Optional[datetime] = None,
        end_time: Optional[datetime] = None,
    ) -> MomentConnection:
        """Get moments with pagination and filtering

        Args:
            info: GraphQL request info
            page: Page number (1-based)
            size: Items per page
            activity_id: Optional activity ID filter
            start_time: Optional start time filter
            end_time: Optional end time filter

        Returns:
            Paginated list of moments

        Raises:
            HTTPException: If user is not authenticated
        """
        moment_service = get_MomentService(info)
        user = get_user_from_context(info)
        if not user:
            raise HTTPException(
                status_code=401,
                detail="Authentication required to list moments",
            )

        moments = moment_service.list_moments(
            page=page,
            size=size,
            activity_id=activity_id,
            start_date=start_time,
            end_date=end_time,
            user_id=str(user.id),
        )
        return MomentConnection.from_pydantic(moments)

    @strawberry.field(
        description="Get recently used activities"
    )
    def getRecentActivities(
        self, info: Info, limit: int = 5
    ) -> List[Activity]:
        """Get recently used activities

        Args:
            info: GraphQL request info
            limit: Maximum number of activities to return

        Returns:
            List of recently used activities

        Raises:
            HTTPException: If user is not authenticated
        """
        moment_service = get_MomentService(info)
        user = get_user_from_context(info)
        if not user:
            raise HTTPException(
                status_code=401,
                detail="Authentication required to get recent activities",
            )

        return moment_service.list_recent_activities(
            str(user.id), limit
        )

================
File: schemas/pydantic/ActivitySchema.py
================
from typing import Dict, Optional, List, Any
from pydantic import BaseModel, Field, validator
import re
from schemas.base.activity_schema import ActivityData


class ActivityBase(BaseModel):
    """Base schema for Activity with common attributes"""

    name: str = Field(..., min_length=1, max_length=255)
    description: str = Field(
        ..., min_length=1, max_length=1000
    )
    activity_schema: Dict[str, Any] = Field(
        ...,
        description="JSON Schema that defines the structure of moment data",
    )
    icon: str = Field(..., min_length=1, max_length=255)
    color: str = Field(..., min_length=1, max_length=7)

    def to_domain(self) -> ActivityData:
        """Convert to domain model"""
        return ActivityData.from_dict(self.dict())

    @validator("color")
    @classmethod
    def validate_color(cls, v: str) -> str:
        """Validate that color is a valid hex color code"""
        if not re.match(r"^#[0-9A-Fa-f]{6}$", v):
            raise ValueError(
                "Color must be a valid hex color code (e.g., #4A90E2)"
            )
        return v


class ActivityCreate(ActivityBase):
    """Schema for creating a new Activity"""

    user_id: Optional[str] = Field(
        None,
        description="ID of the user creating the activity",
    )


class ActivityUpdate(BaseModel):
    """Schema for updating an existing Activity"""

    name: Optional[str] = Field(
        None, min_length=1, max_length=255
    )
    description: Optional[str] = Field(
        None, min_length=1, max_length=1000
    )
    activity_schema: Optional[Dict[str, Any]] = None
    icon: Optional[str] = Field(
        None, min_length=1, max_length=255
    )
    color: Optional[str] = Field(
        None, min_length=1, max_length=7
    )

    def to_domain(
        self, existing: ActivityData
    ) -> ActivityData:
        """Convert to domain model, preserving existing data"""
        update_dict = self.dict(exclude_unset=True)
        existing_dict = existing.to_dict()
        existing_dict.update(update_dict)
        return ActivityData.from_dict(existing_dict)

    @validator("color")
    @classmethod
    def validate_color(
        cls, v: Optional[str]
    ) -> Optional[str]:
        """Validate that color is a valid hex color code if provided"""
        if v is not None and not re.match(
            r"^#[0-9A-Fa-f]{6}$", v
        ):
            raise ValueError(
                "Color must be a valid hex color code (e.g., #4A90E2)"
            )
        return v


class ActivityResponse(BaseModel):
    """Schema for Activity response"""

    id: int
    name: str
    description: str
    activity_schema: Dict[str, Any]
    icon: str
    color: str
    user_id: str
    moment_count: int = 0

    @classmethod
    def from_domain(
        cls, activity: ActivityData
    ) -> "ActivityResponse":
        """Create from domain model"""
        return cls(**activity.to_dict())

    class Config:
        from_attributes = True


class ActivityList(BaseModel):
    """Schema for listing activities with pagination metadata"""

    items: List[ActivityResponse]
    total: int
    page: int = Field(
        ge=1,
        description="Current page number (1-based)",
    )
    size: int = Field(
        ge=1,
        le=100,
        description="Number of items per page (max 100)",
    )
    pages: int = Field(
        description="Total number of pages",
    )

    @validator("pages", pre=True)
    @classmethod
    def calculate_pages(cls, v: int, values: dict) -> int:
        """Calculate total pages based on total items and page size"""
        if "total" in values and "size" in values:
            return (
                values["total"] + values["size"] - 1
            ) // values["size"]
        return v

    class Config:
        from_attributes = True

================
File: schemas/pydantic/MomentSchema.py
================
from typing import Dict, Optional, List, Any
from datetime import datetime
from pydantic import BaseModel, Field, validator
from schemas.base.moment_schema import MomentData
from .ActivitySchema import ActivityResponse


class MomentBase(BaseModel):
    """Base schema for Moment with common attributes"""

    activity_id: int = Field(..., gt=0)
    data: Dict[str, Any] = Field(
        ...,
        description="Activity-specific data matching activity's schema",
    )
    timestamp: Optional[datetime] = Field(
        None, description="UTC timestamp of the moment"
    )

    def to_domain(self) -> MomentData:
        """Convert to domain model"""
        return MomentData.from_dict(self.dict())

    @validator("timestamp")
    @classmethod
    def default_timestamp(
        cls, v: Optional[datetime]
    ) -> datetime:
        """Set default timestamp to current UTC time if not provided"""
        return v or datetime.utcnow()


class MomentCreate(MomentBase):
    """Schema for creating a new Moment"""

    pass


class MomentUpdate(BaseModel):
    """Schema for updating an existing Moment"""

    data: Optional[Dict[str, Any]] = Field(
        None,
        description="Activity-specific data matching activity's schema",
    )
    timestamp: Optional[datetime] = None

    def to_domain(self, existing: MomentData) -> MomentData:
        """Convert to domain model, preserving existing data"""
        update_dict = self.dict(exclude_unset=True)
        existing_dict = existing.to_dict()
        existing_dict.update(update_dict)
        return MomentData.from_dict(existing_dict)


class MomentResponse(BaseModel):
    """Schema for Moment response"""

    id: int
    activity_id: int
    data: Dict[str, Any]
    timestamp: datetime
    activity: ActivityResponse

    @classmethod
    def from_domain(
        cls, moment: MomentData, activity: ActivityResponse
    ) -> "MomentResponse":
        """Create from domain model"""
        moment_dict = moment.to_dict()
        moment_dict["activity"] = activity
        return cls(**moment_dict)

    class Config:
        from_attributes = True


class MomentList(BaseModel):
    """Schema for listing moments with pagination metadata"""

    items: List[MomentResponse]
    total: int
    page: int = Field(
        ge=1, description="Current page number (1-based)"
    )
    size: int = Field(
        ge=1,
        le=100,
        description="Number of items per page (max 100)",
    )
    pages: int = Field(
        0, description="Total number of pages"
    )

    @validator("pages", pre=True)
    @classmethod
    def calculate_pages(cls, v: int, values: dict) -> int:
        """Calculate total pages based on total items and page size"""
        if "total" in values and "size" in values:
            return (
                values["total"] + values["size"] - 1
            ) // values["size"]
        return v

    class Config:
        from_attributes = True

================
File: schemas/pydantic/PaginationSchema.py
================
from pydantic import BaseModel, Field, validator


class PaginationParams(BaseModel):
    """Base schema for pagination parameters"""

    page: int = Field(
        default=1,
        ge=1,
        description="Page number (1-based indexing)",
    )
    size: int = Field(
        default=50,
        ge=1,
        le=100,
        description="Number of items per page (max 100)",
    )

    @validator("page")
    @classmethod
    def validate_page(cls, v: int) -> int:
        """Ensure page number is positive"""
        if v < 1:
            raise ValueError("Page number must be positive")
        return v

    @validator("size")
    @classmethod
    def validate_size(cls, v: int) -> int:
        """Ensure page size is within bounds"""
        if v < 1:
            raise ValueError("Page size must be positive")
        if v > 100:
            raise ValueError("Page size cannot exceed 100")
        return v

================
File: schemas/pydantic/UserSchema.py
================
from pydantic import BaseModel, Field
from typing import Optional
from datetime import datetime
from schemas.base.user_schema import UserData


class UserBase(BaseModel):
    """Base schema for User with common attributes"""

    username: str = Field(
        ...,
        min_length=3,
        max_length=50,
        description="User's unique username",
    )

    def to_domain(self) -> UserData:
        """Convert to domain model"""
        return UserData.from_dict(self.model_dump())


class UserCreate(UserBase):
    """Schema for creating a new user"""

    pass


class UserRegisterResponse(BaseModel):
    """Response model for user registration"""

    id: str
    username: str
    user_secret: str

    @classmethod
    def from_domain(
        cls, user: UserData
    ) -> "UserRegisterResponse":
        """Create from domain model"""
        return cls(**user.to_dict(include_secret=True))


class UserResponse(BaseModel):
    """Full user response model with timestamps"""

    id: str
    username: str
    created_at: datetime
    updated_at: Optional[datetime] = None

    @classmethod
    def from_domain(cls, user: UserData) -> "UserResponse":
        """Create from domain model"""
        return cls(**user.to_dict())

    class Config:
        from_attributes = True


class UserLoginRequest(BaseModel):
    """Request model for user login"""

    user_secret: str = Field(
        ...,
        description="User's secret key for authentication",
    )


class Token(BaseModel):
    """Token response model"""

    access_token: str
    token_type: str = "bearer"

    class Config:
        json_schema_extra = {
            "example": {
                "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
                "token_type": "bearer",
            }
        }

================
File: services/ActivityService.py
================
from typing import List, Optional
from fastapi import HTTPException, Depends
from sqlalchemy.orm import Session
from jsonschema import Draft7Validator
from jsonschema.exceptions import ValidationError
import json

from configs.Database import get_db_connection
from repositories.ActivityRepository import (
    ActivityRepository,
)
from repositories.MomentRepository import MomentRepository
from schemas.pydantic.ActivitySchema import (
    ActivityCreate,
    ActivityUpdate,
    ActivityList,
    ActivityResponse,
)
from schemas.graphql.types.Activity import Activity


class ActivityService:
    def __init__(
        self, db: Session = Depends(get_db_connection)
    ):
        """Initialize the service with database session

        Args:
            db: SQLAlchemy database session
        """
        self.db = db
        self.activity_repository = ActivityRepository(db)
        self.moment_repository = MomentRepository(db)

    def create_activity(
        self, activity_data: ActivityCreate, user_id: str
    ) -> ActivityResponse:
        """Create a new activity with schema validation

        Args:
            activity_data: Activity data to create
            user_id: ID of the user creating the activity

        Returns:
            Created activity response

        Raises:
            HTTPException: If JSON schema validation fails
        """
        try:
            # Validate that the activity_schema is a valid JSON Schema
            Draft7Validator.check_schema(
                activity_data.activity_schema
            )
        except ValidationError as e:
            raise HTTPException(
                status_code=400,
                detail=f"Invalid JSON Schema: {str(e)}",
            )

        activity = self.activity_repository.create(
            instance_or_name=activity_data.name,
            description=activity_data.description,
            activity_schema=activity_data.activity_schema,
            icon=activity_data.icon,
            color=activity_data.color,
            user_id=str(user_id),  # Ensure user_id is string
        )
        return ActivityResponse.from_orm(activity)

    def get_activity(
        self, activity_id: int, user_id: str
    ) -> Optional[ActivityResponse]:
        """Get an activity by ID

        Args:
            activity_id: ID of activity to get
            user_id: ID of user requesting the activity

        Returns:
            Activity response if found, None otherwise
        """
        activity = self.activity_repository.get_by_user(
            activity_id,
            str(user_id),  # Ensure user_id is string
        )
        if not activity:
            return None
        return ActivityResponse.from_orm(activity)

    def list_activities(
        self, user_id: str, page: int = 1, size: int = 100
    ) -> ActivityList:
        """List all activities with pagination

        Args:
            user_id: ID of user requesting activities
            page: Page number (1-based)
            size: Maximum number of items per page

        Returns:
            List of activities with pagination metadata
        """
        # Convert page/size to skip/limit for repository
        skip = (page - 1) * size
        limit = size

        activities = (
            self.activity_repository.list_activities(
                user_id=str(
                    user_id
                ),  # Ensure user_id is string
                skip=skip,
                limit=limit,
            )
        )

        # Convert to list of ActivityResponse objects
        activity_responses = [
            ActivityResponse.from_orm(activity)
            for activity in activities
        ]

        total = len(activity_responses)
        pages = (total + size - 1) // size

        # Create and return ActivityList
        return ActivityList(
            items=activity_responses,
            total=total,
            page=page,
            size=size,
            pages=pages,
        )

    def update_activity(
        self,
        activity_id: int,
        activity_data: ActivityUpdate,
        user_id: str,
    ) -> Optional[ActivityResponse]:
        """Update an activity

        Args:
            activity_id: ID of activity to update
            activity_data: Updated activity data
            user_id: ID of user updating the activity

        Returns:
            Updated activity response if found, None otherwise

        Raises:
            HTTPException: If JSON schema validation fails
        """
        # Get existing activity
        activity = self.activity_repository.get_by_id(
            activity_id,
            str(user_id),  # Ensure user_id is string
        )
        if not activity:
            return None

        # Update fields
        update_data = activity_data.dict(exclude_unset=True)
        if "activity_schema" in update_data:
            try:
                Draft7Validator.check_schema(
                    update_data["activity_schema"]
                )
            except ValidationError as e:
                raise HTTPException(
                    status_code=400,
                    detail=f"Invalid JSON Schema: {str(e)}",
                )

        # Update the activity
        updated = self.activity_repository.update(
            activity_id=activity_id,
            user_id=str(
                user_id
            ),  # Ensure user_id is string
            **update_data,
        )
        if not updated:
            return None
        return ActivityResponse.from_orm(updated)

    def delete_activity(
        self, activity_id: int, user_id: str
    ) -> bool:
        """Delete an activity

        Args:
            activity_id: ID of activity to delete
            user_id: ID of user deleting the activity

        Returns:
            True if activity was deleted, False otherwise
        """
        return self.activity_repository.delete(
            activity_id,
            str(user_id),  # Ensure user_id is string
        )

    # GraphQL specific methods
    def create_activity_graphql(
        self, activity_data: ActivityCreate, user_id: str
    ) -> Activity:
        """Create activity for GraphQL

        Args:
            activity_data: Activity data to create
            user_id: ID of user creating the activity

        Returns:
            Created activity in GraphQL format

        Raises:
            HTTPException: If validation fails
        """
        activity = self.activity_repository.create(
            name=activity_data.name,
            description=activity_data.description,
            activity_schema=activity_data.activity_schema,
            icon=activity_data.icon,
            color=activity_data.color,
            user_id=str(
                user_id
            ),  # Ensure user_id is string
        )
        return Activity.from_db(activity)

    def get_activity_graphql(
        self, activity_id: int, user_id: str
    ) -> Optional[Activity]:
        """Get an activity by ID for GraphQL

        Args:
            activity_id: ID of activity to get
            user_id: ID of user requesting the activity

        Returns:
            Activity in GraphQL format if found, None otherwise
        """
        activity = self.activity_repository.get_by_id(
            activity_id,
            str(user_id),  # Ensure user_id is string
        )
        if not activity:
            return None
        return Activity.from_db(activity)

    def list_activities_graphql(
        self, user_id: str, skip: int = 0, limit: int = 100
    ) -> List[Activity]:
        """List all activities with pagination for GraphQL

        Args:
            user_id: ID of user requesting activities
            skip: Number of items to skip
            limit: Maximum number of items to return

        Returns:
            List of activities in GraphQL format
        """
        activities = (
            self.activity_repository.list_activities(
                user_id=str(
                    user_id
                ),  # Ensure user_id is string
                skip=skip,
                limit=limit,
            )
        )
        return [Activity.from_db(a) for a in activities]

    def update_activity_graphql(
        self,
        activity_id: int,
        activity_data: ActivityUpdate,
        user_id: str,
    ) -> Activity:
        """Update activity for GraphQL

        Args:
            activity_id: ID of activity to update
            activity_data: Updated activity data
            user_id: ID of user updating the activity

        Returns:
            Updated activity in GraphQL format

        Raises:
            HTTPException: If validation fails or activity not found
        """
        # Convert activity_schema to dict if it's a string
        if activity_data.activity_schema and isinstance(
            activity_data.activity_schema, str
        ):
            activity_data.activity_schema = json.loads(
                activity_data.activity_schema
            )

        activity = self.update_activity(
            activity_id,
            activity_data,
            str(user_id),  # Ensure user_id is string
        )
        if not activity:
            raise HTTPException(
                status_code=404, detail="Activity not found"
            )
        return Activity.from_db(activity)

================
File: services/MomentService.py
================
from typing import Optional, List, Dict, cast
from fastapi import HTTPException, Depends
from sqlalchemy.orm import Session
from jsonschema import validate, ValidationError
from datetime import datetime

from schemas.base.moment_schema import MomentData
from schemas.graphql.types.Moment import Moment
from repositories.MomentRepository import MomentRepository
from schemas.graphql.types.Activity import Activity

from configs.Database import get_db_connection
from repositories.ActivityRepository import (
    ActivityRepository,
)
from schemas.pydantic.MomentSchema import (
    MomentCreate,
    MomentUpdate,
    MomentList,
    MomentResponse,
)


class MomentService:
    """Service for handling moment-related operations"""

    def __init__(
        self, db: Session = Depends(get_db_connection)
    ) -> None:
        """Initialize the service with database session

        Args:
            db: SQLAlchemy database session
        """
        self.db = db
        self.moment_repository = MomentRepository(db)
        self.activity_repository = ActivityRepository(db)

    def _validate_pagination(
        self, page: int, size: int
    ) -> None:
        """Validate pagination parameters

        Args:
            page: Page number (1-based)
            size: Items per page

        Raises:
            HTTPException: If parameters are invalid
        """
        if page < 1:
            raise HTTPException(
                status_code=400,
                detail="Page number must be positive",
            )
        if size < 1 or size > 100:
            raise HTTPException(
                status_code=400,
                detail="Page size must be between 1 and 100",
            )

    def create_moment(
        self,
        moment_data: MomentCreate | MomentData,
        user_id: str,
    ) -> MomentResponse:
        """Create a new moment with data validation

        Args:
            moment_data: Moment data to create
            user_id: ID of the user creating the moment

        Returns:
            Created moment response

        Raises:
            HTTPException: If validation fails or activity not found
        """
        # Convert to domain model if needed
        domain_data = (
            moment_data
            if isinstance(moment_data, MomentData)
            else moment_data.to_domain()
        )

        # Get activity to validate data against schema
        activity = (
            self.activity_repository.validate_existence(
                domain_data.activity_id, user_id
            )
        )

        try:
            # Validate moment data against activity schema
            validate(
                instance=domain_data.data,
                schema=activity.activity_schema_dict,
            )
        except ValidationError as e:
            raise HTTPException(
                status_code=400,
                detail=f"Invalid moment data: {str(e)}",
            )

        # Create the moment
        moment = self.moment_repository.create(
            instance_or_activity_id=domain_data.activity_id,
            data=domain_data.data,
            user_id=user_id,
            timestamp=domain_data.timestamp,
        )

        return MomentResponse.from_orm(moment)

    def list_moments(
        self,
        page: int,
        size: int,
        activity_id: Optional[int] = None,
        start_date: Optional[datetime] = None,
        end_date: Optional[datetime] = None,
        user_id: Optional[str] = None,
    ) -> MomentList:
        """List moments with filtering and pagination

        Args:
            page: Page number (1-based)
            size: Items per page
            activity_id: Optional activity ID to filter by
            start_date: Optional start date to filter by
            end_date: Optional end date to filter by
            user_id: Optional user ID to filter by

        Returns:
            List of moments with pagination metadata

        Raises:
            HTTPException: If pagination parameters are invalid
        """
        self._validate_pagination(page, size)

        moments = self.moment_repository.list_moments(
            page=page,
            size=size,
            activity_id=activity_id,
            start_time=start_date,
            end_time=end_date,
            user_id=user_id,
        )
        return moments

    def get_moment(
        self, moment_id: int, user_id: str
    ) -> MomentResponse:
        """Get a moment by ID

        Args:
            moment_id: ID of the moment to get
            user_id: ID of the user requesting the moment

        Returns:
            Moment response

        Raises:
            HTTPException: If moment not found or user not authorized
        """
        moment = self.moment_repository.get(moment_id)
        if not moment or moment.activity.user_id != user_id:
            raise HTTPException(
                status_code=404, detail="Moment not found"
            )
        return MomentResponse.from_orm(moment)

    def get_moment_graphql(
        self, moment_id: int, user_id: str
    ) -> Optional[Moment]:
        """Get a moment by ID for GraphQL

        Args:
            moment_id: ID of the moment to get
            user_id: ID of the user requesting the moment

        Returns:
            Moment or None if not found
        """
        try:
            moment = self.get_moment(moment_id, user_id)
            return Moment.from_db(moment)
        except HTTPException:
            return None

    def update_moment(
        self,
        moment_id: int,
        moment_data: MomentUpdate,
        user_id: str,
    ) -> MomentResponse:
        """Update a moment

        Args:
            moment_id: ID of the moment to update
            moment_data: New moment data
            user_id: ID of the user updating the moment

        Returns:
            Updated moment response

        Raises:
            HTTPException: If moment not found, user not authorized,
            or validation fails
        """
        moment = self.moment_repository.get(moment_id)
        if not moment or moment.activity.user_id != user_id:
            raise HTTPException(
                status_code=404, detail="Moment not found"
            )

        # If updating data, validate against activity schema
        if moment_data.data is not None:
            try:
                validate(
                    instance=moment_data.data,
                    schema=moment.activity.activity_schema_dict,
                )
            except ValidationError as e:
                raise HTTPException(
                    status_code=400,
                    detail=f"Invalid moment data: {str(e)}",
                )

        update_dict = moment_data.dict(exclude_unset=True)
        updated = self.moment_repository.update(
            moment_id=moment_id, **update_dict
        )
        if not updated:
            raise HTTPException(
                status_code=404, detail="Moment not found"
            )
        return MomentResponse.from_orm(updated)

    def list_recent_activities(
        self, user_id: str, limit: int = 5
    ) -> List[Activity]:
        """Get recently used activities for a user

        Args:
            user_id: ID of the user
            limit: Maximum number of activities to return

        Returns:
            List of unique activities from recent moments

        Raises:
            HTTPException: If limit is invalid
        """
        if limit < 1 or limit > 100:
            raise HTTPException(
                status_code=400,
                detail="Limit must be between 1 and 100",
            )

        recent_moments = (
            self.moment_repository.get_recent_by_user(
                user_id=user_id, limit=limit
            )
        )
        # Get unique activities from recent moments
        activities: Dict[int, Activity] = {}
        for moment in recent_moments:
            activity_id = cast(int, moment.activity_id)
            if activity_id not in activities:
                activities[activity_id] = Activity.from_db(
                    moment.activity
                )
        return list(activities.values())

================
File: services/UserService.py
================
from typing import Tuple
from fastapi import Depends, HTTPException, status
from sqlalchemy.orm import Session
import re

from configs.Database import get_db_connection
from repositories.UserRepository import UserRepository
from models.UserModel import User
from utils.security import (
    generate_api_key,
    hash_secret,
    parse_api_key,
)


class UserService:
    def __init__(
        self, db: Session = Depends(get_db_connection)
    ):
        self.user_repository = UserRepository(db)

    def _validate_username(self, username: str) -> None:
        """Validate username format"""
        if not re.match("^[a-zA-Z0-9_-]{3,50}$", username):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=(
                    "Username must be 3-50 characters long and contain only "
                    "letters, numbers, underscores, and hyphens"
                ),
            )

    def register_user(
        self, username: str
    ) -> Tuple[User, str]:
        """Register a new user and return the user along with their API key"""
        # Validate username format
        self._validate_username(username)

        # Generate API key components
        key_id, secret, full_key = generate_api_key()
        hashed_secret = hash_secret(secret)

        # Create the user with key_id and hashed secret
        try:
            user = self.user_repository.create_user(
                username=username,
                key_id=key_id,
                user_secret=hashed_secret,
            )
            # Return the user and the full API key
            return user, full_key
        except HTTPException as e:
            raise e
        except Exception as e:
            raise HTTPException(
                status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                detail=f"Error creating user: {str(e)}",
            )

    def authenticate_user(self, api_key: str) -> User:
        """Authenticate a user by their API key and return the user"""
        try:
            # Parse the API key into key_id and secret
            key_id, secret = parse_api_key(api_key)

            # Get user by key_id (fast lookup)
            user = self.user_repository.get_by_key_id(
                key_id
            )
            if not user:
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Invalid API key",
                    headers={"WWW-Authenticate": "Bearer"},
                )

            # Verify the secret
            if user.user_secret != hash_secret(secret):
                raise HTTPException(
                    status_code=status.HTTP_401_UNAUTHORIZED,
                    detail="Invalid API key",
                    headers={"WWW-Authenticate": "Bearer"},
                )

            return user
        except ValueError:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid API key format",
                headers={"WWW-Authenticate": "Bearer"},
            )

================
File: utils/json_utils.py
================
import json
from typing import Dict, Union, TypeVar, Optional

T = TypeVar("T", Dict, str)


def ensure_dict(value: Union[str, Dict, None]) -> Dict:
    """
    Ensure a value is a dictionary, converting from JSON string if necessary.

    Args:
        value: A string containing JSON, a dictionary, or None

    Returns:
        Dict: The input converted to a dictionary,
        or an empty dict if conversion fails
    """
    if value is None:
        return {}
    if isinstance(value, str):
        try:
            return json.loads(value)
        except json.JSONDecodeError:
            return {}
    if isinstance(value, dict):
        return value
    return {}


def ensure_string(value: Union[str, Dict, None]) -> str:
    """
    Ensure a value is a JSON string, converting from dictionary if necessary.

    Args:
        value: A dictionary, JSON string, or None

    Returns:
        str: The input converted to a JSON string, or "{}" if conversion fails
    """
    if value is None:
        return "{}"
    if isinstance(value, str):
        try:
            # Validate it's proper JSON by parsing and re-stringifying
            return json.dumps(json.loads(value))
        except json.JSONDecodeError:
            return "{}"
    if isinstance(value, dict):
        return json.dumps(value)
    return "{}"


def safe_json_loads(value: Optional[str]) -> Dict:
    """
    Safely load a JSON string into a dictionary.

    Args:
        value: A string containing JSON or None

    Returns:
        Dict: The parsed dictionary, or an empty dict if parsing fails
    """
    try:
        return json.loads(value) if value else {}
    except json.JSONDecodeError:
        return {}

================
File: utils/security.py
================
from datetime import datetime, timedelta
from typing import Optional, Dict, Tuple
from jose import JWTError, jwt
import bcrypt
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
import os
import secrets
from dotenv import load_dotenv
import hashlib
from uuid import uuid4

# Load environment variables
load_dotenv()

# JWT Configuration
SECRET_KEY = os.getenv(
    "JWT_SECRET_KEY", "your-secret-key-for-testing"
)
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

# OAuth2 scheme for token authentication
oauth2_scheme = OAuth2PasswordBearer(
    tokenUrl="v1/auth/token"
)


def create_access_token(
    data: Dict, expires_delta: Optional[timedelta] = None
) -> str:
    """Create a JWT access token"""
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(
            minutes=ACCESS_TOKEN_EXPIRE_MINUTES
        )

    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(
        to_encode, SECRET_KEY, algorithm=ALGORITHM
    )
    return encoded_jwt


def verify_token(token: str) -> Optional[str]:
    """Verify a JWT token and return the user_id if valid"""
    try:
        payload = jwt.decode(
            token, SECRET_KEY, algorithms=[ALGORITHM]
        )
        user_id: str = payload.get("sub")
        if user_id is None:
            return None
        return user_id
    except JWTError:
        return None


def generate_user_secret() -> str:
    """Generate a secure random user secret"""
    return secrets.token_urlsafe(32)


def hash_user_secret(user_secret: str) -> str:
    """Hash a user secret using bcrypt"""
    # Convert the user_secret to bytes and generate a salt
    password = user_secret.encode("utf-8")
    salt = bcrypt.gensalt()
    # Hash the password
    hashed = bcrypt.hashpw(password, salt)
    # Return the hash as a string
    return hashed.decode("utf-8")


def verify_user_secret(
    plain_secret: str, hashed_secret: str
) -> bool:
    """Verify a user secret against its hash using bcrypt"""
    try:
        # Convert strings to bytes for bcrypt
        password = plain_secret.encode("utf-8")
        stored_hash = hashed_secret.encode("utf-8")
        # Check if the password matches
        return bcrypt.checkpw(password, stored_hash)
    except Exception:
        return False


def hash_secret(secret: str) -> str:
    """Hash a secret using a secure hashing algorithm"""
    return hashlib.sha256(secret.encode()).hexdigest()


def verify_secret(
    plain_secret: str, hashed_secret: str
) -> bool:
    """Verify a secret against its hash"""
    return bcrypt.checkpw(
        plain_secret.encode(), hashed_secret.encode()
    )


def create_access_token_jwt(
    data: Dict, expires_delta: Optional[timedelta] = None
) -> str:
    """Create a JWT access token"""
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(
            minutes=ACCESS_TOKEN_EXPIRE_MINUTES
        )
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(
        to_encode, SECRET_KEY, algorithm=ALGORITHM
    )
    return encoded_jwt


def decode_token(token: str) -> Dict:
    """Decode a JWT token"""
    try:
        payload = jwt.decode(
            token, SECRET_KEY, algorithms=[ALGORITHM]
        )
        return payload
    except jwt.ExpiredSignatureError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Token has expired",
            headers={"WWW-Authenticate": "Bearer"},
        )
    except jwt.JWTError:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )


async def get_current_user(
    token: str = Depends(oauth2_scheme),
) -> Dict:
    """Get the current user from the JWT token"""
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )

    try:
        payload = decode_token(token)
        user_id = payload.get("sub")
        if user_id is None:
            raise credentials_exception
        return {"user_id": user_id}
    except jwt.JWTError:
        raise credentials_exception


def generate_api_key() -> Tuple[str, str, str]:
    """
    Generate an API key pair (key_id, secret, full_key)
    Returns:
        Tuple containing (key_id, secret, full_key)
        full_key is in format: {key_id}.{secret}
    """
    key_id = str(uuid4())
    secret = secrets.token_urlsafe(32)
    full_key = f"{key_id}.{secret}"
    return key_id, secret, full_key


def parse_api_key(api_key: str) -> Tuple[str, str]:
    """
    Parse an API key into its components
    Args:
        api_key: The full API key in format {key_id}.{secret}
    Returns:
        Tuple of (key_id, secret)
    Raises:
        ValueError if the API key format is invalid
    """
    try:
        key_id, secret = api_key.split(".", 1)
        return key_id, secret
    except ValueError:
        raise ValueError("Invalid API key format")

================
File: .env.test
================
API_VERSION=1.0.0
APP_NAME=friday-api
DATABASE_DIALECT=mysql
DATABASE_HOSTNAME=localhost
DATABASE_NAME=test_fridaystore
DATABASE_PASSWORD=1234567890
DATABASE_PORT=3306
DATABASE_USERNAME=root
DEBUG_MODE=true

================
File: .gitignore
================
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
pip-wheel-metadata/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST
.vscode/

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt
repomix-output.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
# .python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
# Pipfile.lock

# PEP 582; used by e.g. github.com/David-OConnor/pyflow
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/
docs/bugs.md

================
File: .pre-commit-config.yaml
================
# See https://pre-commit.com for more information
# See https://pre-commit.com/hooks.html for more hooks
repos:
    -   repo: https://github.com/pre-commit/pre-commit-hooks
        rev: v3.2.0
        hooks:
        -   id: trailing-whitespace
        -   id: end-of-file-fixer
        -   id: check-yaml
        -   id: check-added-large-files
    -   repo: https://github.com/psf/black
        rev: 22.3.0
        hooks:
        -   id: black
exclude: env
fail_fast: true

================
File: .python-version
================
3.12.8

================
File: .windsurfrules
================
1. Always follow clean code and best practices
2. Use comments to explain your code
3. Use consistent naming conventions for variables and functions
4. Use descriptive variable names
5. Use meaningful function names
6. Use self-explanatory variable names
7. Most of the time, I will have a document logging progress/plan. Keep an eye on that, and also update specified progress docs as you change code.
8. I have absolute obsession with code quality and maintainability, this means I won't take a compromise to "get things working", but only implement something if it is the "right" way.
9. I will (eventually) write tests for everything I write.
10. Python linters are your best friends, I use flake8 and black.
11. I use mypy to type check, and prefer to not have any open warnings/errors.
12. I work across multiple machines, so I use git to track changes and pull requests. 
13. I use windows and macOS, so I use git bash and powershell. This also means, my documentation and plans have to work for both.
14. This project uses pipenv to manage dependencies. So, we should follow pipenv best practices.

================
File: dependencies.py
================
from fastapi import Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import Optional
from configs.Database import get_db_connection
from configs.OpenAPI import security
from repositories.UserRepository import UserRepository
from utils.security import verify_token
from models.UserModel import User
from fastapi.security import HTTPAuthorizationCredentials


async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(
        security
    ),
    db: Session = Depends(get_db_connection),
) -> User:
    """Get the current authenticated user from the bearer token"""
    try:
        # Get the token from credentials
        token = credentials.credentials

        # Verify the JWT token and get user_id
        user_id = verify_token(token)
        if not user_id:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid token",
            )

        # Get user from database
        repository = UserRepository(db)
        user = repository.get_by_id(user_id)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="User not found",
            )

        return user
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail=str(e),
        )


async def get_optional_user(
    db: Session = Depends(get_db_connection),
    credentials: Optional[
        HTTPAuthorizationCredentials
    ] = Depends(security),
) -> Optional[User]:
    """Get the current user if authenticated, otherwise return None"""
    try:
        if not credentials:
            return None

        # Get the token from credentials
        token = credentials.credentials

        # Verify the JWT token and get user_id
        user_id = verify_token(token)
        if not user_id:
            return None

        # Get user from database
        repository = UserRepository(db)
        user = repository.get_by_id(user_id)
        return user
    except Exception:
        return None

================
File: LICENSE
================
MIT License

Copyright (c) 2022 Progyan Bhattacharya

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

================
File: main.py
================
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from strawberry import Schema
from strawberry.fastapi import GraphQLRouter

from configs.Environment import get_environment_variables
from configs.GraphQL import get_graphql_context
from metadata.Tags import Tags
from routers.v1.ActivityRouter import (
    router as ActivityRouter,
)
from routers.v1.MomentRouter import router as MomentRouter
from routers.v1.AuthRouter import router as AuthRouter
from schemas.graphql.Query import Query
from schemas.graphql.Mutation import Mutation

# Application Environment Configuration
env = get_environment_variables()

# FastAPI Configuration
app = FastAPI(
    title=env.APP_NAME,
    version=env.API_VERSION,
    openapi_tags=Tags,
    openapi_url="/openapi.json",
    docs_url="/docs",
    redoc_url="/redoc",
)

# CORS Configuration
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# REST API Configuration
app.include_router(ActivityRouter)
app.include_router(MomentRouter)
app.include_router(AuthRouter)

# GraphQL Configuration
schema = Schema(query=Query, mutation=Mutation)
graphql = GraphQLRouter(
    schema,
    context_getter=get_graphql_context,
    graphiql=True,
)
app.include_router(graphql, prefix="/graphql")

================
File: mypy.ini
================
[mypy]
plugins = sqlalchemy.ext.mypy.plugin
python_version = 3.8
warn_return_any = True
warn_unused_configs = True
disallow_untyped_defs = True
disallow_incomplete_defs = True
check_untyped_defs = True
disallow_untyped_decorators = False
no_implicit_optional = True
warn_redundant_casts = True
warn_unused_ignores = False
warn_no_return = True
warn_unreachable = True

[mypy.plugins.sqlalchemy.ext.mypy.plugin]
warn_relationship_base = True
warn_nullable = True

[mypy-sqlalchemy.*]
ignore_missing_imports = True

================
File: Pipfile
================
[[source]]
url = "https://pypi.org/simple"
verify_ssl = true
name = "pypi"

[packages]
fastapi = ">=0.75.1"
sqlalchemy = ">=1.4.35"
uvicorn = {extras = ["standard"], version = ">=0.17.6"}
python-dotenv = ">=0.20.0"
strawberry-graphql = {extras = ["fastapi"], version = ">=0.114.0"}
jsonschema = ">=4.21.1"
pydantic = ">=2.0.0"
pydantic-settings = ">=2.0.3"
mysqlclient = "*"
python-jose = {extras = ["cryptography"], version = "*"}
passlib = {extras = ["bcrypt"], version = "*"}
black = "*"
types-jsonschema = "*"
types-sqlalchemy = "*"

[dev-packages]
pre-commit = ">=2.18.1"
pytest = ">=8.3.4"
pytest-asyncio = ">=0.24.0"
pytest-cov = ">=3.0.0"
black = ">=22.3.0"
strawberry-graphql = {extras = ["debug-server"], version = ">=0.114.0"}
httpx = "*"

[requires]
python_version = "3.12"

================
File: pyproject.toml
================
[tool.black]
line-length = 60

[tool.isort]
profile = "black"
src_paths = ["configs", "core", "dependencies", "models", "repositories", "routers", "schemas", "services"]
virtual_env = "env"

[tool.pytest.ini_options]
pythonpath = [
  "."
]
testpaths = [
  "__tests__"
]
python_files = ["test_*.py"]
python_classes = ["Test*"]
python_functions = ["test_*"]
asyncio_mode = "strict"
markers = [
    "unit: marks tests as unit tests",
    "integration: marks tests as integration tests",
]

================
File: README.md
================
# Friday API

A powerful life logging API built with FastAPI and GraphQL. Track your daily activities and moments with rich, structured data.

[![Python](https://img.shields.io/badge/python-3670A0?style=for-the-badge&logo=python&logoColor=ffdd54)](https://docs.python.org/3/)
[![FastAPI](https://img.shields.io/badge/FastAPI-005571?style=for-the-badge&logo=fastapi)](https://fastapi.tiangolo.com/)
[![OpenAPI](https://img.shields.io/badge/openapi-6BA539?style=for-the-badge&logo=openapi-initiative&logoColor=fff)](https://www.openapis.org/)
[![Swagger](https://img.shields.io/badge/-Swagger-%23Clojure?style=for-the-badge&logo=swagger&logoColor=white)](https://swagger.io/)
[![GraphQL](https://img.shields.io/badge/-GraphQL-E10098?style=for-the-badge&logo=graphql&logoColor=white)](https://graphql.org/)
[![Code style: black](https://img.shields.io/badge/code%20style-black-000000.svg?style=for-the-badge)](https://black.readthedocs.io/en/stable/)
[![Typed with: pydantic](https://img.shields.io/badge/typed%20with-pydantic-BA600F.svg?style=for-the-badge)](https://docs.pydantic.dev/)

## Features

- **Activity Management**: Create and manage activity types with custom JSON schemas
- **Moment Logging**: Log moments with structured data based on activity schemas
- **Flexible Querying**: Filter moments by time range and activity type
- **Dual API Support**: Both REST and GraphQL interfaces
- **Data Validation**: Automatic validation of moment data against activity schemas
- **UTC Time Handling**: Proper timezone handling for global usage

## Getting Started

### Prerequisites

- Python 3.8+
- MySQL 8.0+
- [Pipenv](https://pipenv.pypa.io/en/latest/)

### Installation

1. Clone the repository:
```bash
git clone https://github.com/yourusername/friday-api.git
cd friday-api
```

2. Install dependencies:
```bash
pipenv install
```

3. Set up your environment variables in `.env`:
```env
APP_ENV=development
APP_NAME=friday-api
DATABASE_DIALECT=mysql
DATABASE_HOSTNAME=localhost
DATABASE_NAME=test_fridaystore
DATABASE_PASSWORD=your_password
DATABASE_PORT=3306
DATABASE_USERNAME=your_username
```

4. Initialize the database:
```bash
# Run the SQL script in scripts/init_database.sql
```

5. Start the server:
```bash
pipenv run uvicorn main:app --reload
```

The API will be available at:
- REST API: http://localhost:8000/v1
- GraphQL Playground: http://localhost:8000/graphql
- API Documentation: http://localhost:8000/docs

## API Documentation

See [API Reference](docs/api-reference.md) for detailed endpoint documentation.

### Quick Examples

#### Create an Activity
```bash
curl -X POST "http://localhost:8000/v1/activities" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Reading",
    "description": "Track reading sessions",
    "activity_schema": {
      "type": "object",
      "properties": {
        "book": { "type": "string" },
        "pages": { "type": "number" },
        "notes": { "type": "string" }
      }
    },
    "icon": "ðŸ“š",
    "color": "#4A90E2"
  }'
```

#### Log a Moment
```bash
curl -X POST "http://localhost:8000/v1/moments" \
  -H "Content-Type: application/json" \
  -d '{
    "activity_id": 1,
    "timestamp": "2024-12-11T05:30:00Z",
    "data": {
      "book": "The Pragmatic Programmer",
      "pages": 50,
      "notes": "Great chapter on code quality"
    }
  }'
```

## Development

### Project Structure
```
friday-api/
â”œâ”€â”€ configs/            # Configuration modules
â”œâ”€â”€ models/            # SQLAlchemy models
â”œâ”€â”€ schemas/           # Pydantic & GraphQL schemas
â”‚   â”œâ”€â”€ pydantic/     # Data validation schemas
â”‚   â””â”€â”€ graphql/      # GraphQL type definitions
â”œâ”€â”€ repositories/     # Database operations
â”œâ”€â”€ services/        # Business logic
â”œâ”€â”€ routers/         # API endpoints
â”‚   â””â”€â”€ v1/         # API version 1
â””â”€â”€ docs/           # Documentation
```

### Running Tests
```bash
pipenv run pytest
```

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.
